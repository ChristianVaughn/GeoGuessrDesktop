[
  {
    "id": "ccf0277e-414d-4fcc-9a8a-4f56f36d0c3e",
    "name": "GeoGuessr Country Streak",
    "code": "// ==UserScript==\r\n// @name         GeoGuessr Country Streak\r\n// @description  Adds a country streak counter that automatically updates while you play\r\n// @version      1.26\r\n// @author       miraclewhips\r\n// @match        *://*.geoguessr.com/*\r\n// @icon         https://www.google.com/s2/favicons?domain=geoguessr.com\r\n// @grant        unsafeWindow\r\n// @run-at       document-start\r\n// @require      https://miraclewhips.dev/geoguessr-event-framework/geoguessr-event-framework.min.js?v=15\r\n// @require      https://miraclewhips.dev/geoguessr-event-framework/geoguessr-streak-framework.min.js?v=15\r\n// @copyright    2022, miraclewhips (https://github.com/miraclewhips)\r\n// @license      MIT\r\n// @downloadURL  https://github.com/miraclewhips/geoguessr-userscripts/raw/master/geoguessr-country-streak.user.js\r\n// @updateURL    https://github.com/miraclewhips/geoguessr-userscripts/raw/master/geoguessr-country-streak.user.js\r\n// ==/UserScript==\r\n\r\n/* ------------------------------------------------------------------------------- */\r\n/* ----- SETTINGS (MUST RELOAD PAGE FOR CHANGES TO TAKE EFFECT) ------------------ */\r\n/* ------------------------------------------------------------------------------- */\r\nconst LANGUAGE = \"en\";   // ISO 639-1 language code - https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\r\nconst CHALLENGE = true;  // Set to false to disable streaks on challenge links\r\nconst AUTOMATIC = true;  // Set to false for a manual counter (controlled by keyboard shortcuts only)\r\n\r\n/* ------------------------------------------------------------------------------- */\r\n/* ----- KEYBOARD SHORTCUTS (MUST RELOAD PAGE FOR CHANGES TO TAKE EFFECT) -------- */\r\n/* ------------------------------------------------------------------------------- */\r\nconst KEYBOARD_SHORTCUTS = {\r\n\treset: '0',     // reset streak to 0\r\n\tincrement: '1', // increment streak by 1\r\n\tdecrement: '2', // decrement streak by 1\r\n\trestore: '8',   // restore your streak to it's previous value\r\n};\r\n\r\n\r\n\r\n/* ############################################################################### */\r\n/* ##### DON'T MODIFY ANYTHING BELOW HERE UNLESS YOU KNOW WHAT YOU ARE DOING ##### */\r\n/* ############################################################################### */\r\n\r\nconst GSF = new GeoGuessrStreakFramework({\r\n\tstorage_identifier: 'MW_GeoGuessrCountryStreak',\r\n\tname: 'Country Streak',\r\n\tterms: {\r\n\t\tsingle: 'country',\r\n\t\tplural: 'countries'\r\n\t},\r\n\tenabled_on_challenges: CHALLENGE,\r\n\tautomatic: AUTOMATIC,\r\n\tlanguage: LANGUAGE,\r\n\tonly_match_country_code: true,\r\n\taddress_matches: ['country'],\r\n\tkeyboard_shortcuts: KEYBOARD_SHORTCUTS,\r\n});\r\n",
    "enabled": true,
    "order": 0,
    "url": "https://github.com/miraclewhips/geoguessr-userscripts/raw/refs/heads/master/geoguessr-country-streak.user.js",
    "version": "1.26",
    "description": "Adds a country streak counter that automatically updates while you play",
    "author": "miraclewhips",
    "requires": [
      "https://miraclewhips.dev/geoguessr-event-framework/geoguessr-event-framework.min.js?v=15",
      "https://miraclewhips.dev/geoguessr-event-framework/geoguessr-streak-framework.min.js?v=15"
    ],
    "last_updated": 1765264457,
    "last_fetch_error": null
  },
  {
    "id": "5611885a-49f6-4e0a-a342-a4b13c7bf809",
    "name": "GeoGuessr Learnable Meta",
    "code": "// ==UserScript==\n// @name         GeoGuessr Learnable Meta\n// @namespace    geometa\n// @version      0.88\n// @author       monkey\n// @description  UserScript for GeoGuessr Learnable Meta maps\n// @icon         https://learnablemeta.com/favicon.png\n// @downloadURL  https://github.com/likeon/geometa/raw/main/dist/geometa.user.js\n// @updateURL    https://github.com/likeon/geometa/raw/main/dist/geometa.user.js\n// @match        *://*.geoguessr.com/*\n// @require      https://raw.githubusercontent.com/miraclewhips/geoguessr-event-framework/5e449d6b64c828fce5d2915772d61c7f95263e34/geoguessr-event-framework.js\n// @connect      learnablemeta.com\n// @grant        GM_addStyle\n// @grant        GM_getValue\n// @grant        GM_info\n// @grant        GM_registerMenuCommand\n// @grant        GM_setValue\n// @grant        GM_xmlhttpRequest\n// @grant        unsafeWindow\n// @run-at       document-start\n// ==/UserScript==\n\n(e=>{if(typeof GM_addStyle==\"function\"){GM_addStyle(e);return}const o=document.createElement(\"style\");o.textContent=e,document.head.append(o)})(` .loadership_ZOJAQ.svelte-i1jlc0{display:flex;position:relative;width:72px;height:72px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0){position:absolute;width:8px;height:8px;border-radius:50%;background:#fff;animation:svelte-i1jlc0-loadership_ZOJAQ_scale 1.2s infinite,svelte-i1jlc0-loadership_ZOJAQ_fade 1.2s infinite;animation-timing-function:linear}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(1){animation-delay:0s;top:62px;left:32px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(2){animation-delay:-.1s;top:58px;left:47px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(3){animation-delay:-.2s;top:47px;left:58px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(4){animation-delay:-.3s;top:32px;left:62px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(5){animation-delay:-.4s;top:17px;left:58px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(6){animation-delay:-.5s;top:6px;left:47px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(7){animation-delay:-.6s;top:2px;left:32px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(8){animation-delay:-.7s;top:6px;left:17px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(9){animation-delay:-.8s;top:17px;left:6px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(10){animation-delay:-.9s;top:32px;left:2px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(11){animation-delay:-1s;top:47px;left:6px}.loadership_ZOJAQ.svelte-i1jlc0 div:where(.svelte-i1jlc0):nth-child(12){animation-delay:-1.1s;top:58px;left:17px}@keyframes svelte-i1jlc0-loadership_ZOJAQ_scale{0%,20%,80%,to{transform:scale(1)}50%{transform:scale(1.5)}}@keyframes svelte-i1jlc0-loadership_ZOJAQ_fade{0%,20%,80%,to{opacity:.8}50%{opacity:1}}.fi.svelte-7lhsry{width:1.5em;height:1em;display:inline-block;vertical-align:middle;padding-right:3px}.carousel.svelte-fofh7f{position:relative;overflow:hidden;margin:0 auto}.image-wrapper.svelte-fofh7f{width:100%;height:100%;display:flex;justify-content:center;align-items:center;cursor:zoom-in}.responsive-image.svelte-fofh7f{max-width:100%;height:100%;display:block;object-fit:contain}.lens.svelte-fofh7f{position:absolute;pointer-events:none;border:2px solid #aaa;border-radius:50%;box-shadow:0 0 8px #00000080}.click-area.svelte-fofh7f{position:absolute;top:0;bottom:0;width:1.4em;cursor:pointer}.prev-area.svelte-fofh7f{left:0}.next-area.svelte-fofh7f{right:0}.prev.svelte-fofh7f,.next.svelte-fofh7f{background-color:#00000080;color:#fff;border:none;font-size:1.2em;padding:.2em;cursor:pointer;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%)}.prev.svelte-fofh7f{left:0}.next.svelte-fofh7f{right:0}.indicators.svelte-fofh7f{position:absolute;bottom:15px;left:50%;transform:translate(-50%);display:flex;justify-content:center;align-items:center;gap:8px}.indicator.svelte-fofh7f{width:12px;height:12px;background-color:#ffffff80;border-radius:50%;cursor:pointer;border:none;padding:0;flex-shrink:0}.indicator.active.svelte-fofh7f{background-color:#fff}.geometa-footer a{color:#188bd2;text-decoration:none}.geometa-footer a:hover{text-decoration:underline}.geometa-container.svelte-a3mhc8{position:absolute;top:13rem;left:1rem;z-index:50;display:flex;flex-direction:column;gap:5px;align-items:flex-start;background:var(--ds-color-purple-100);padding:6px 10px;border-radius:5px;font-size:17px;width:min(25%,500px);resize:both;overflow:auto}.geometa-container.svelte-a3mhc8>.header:where(.svelte-a3mhc8){margin-top:0}.geometa-footer.svelte-a3mhc8{color:#d3d3d3;font-size:small}.announcement.svelte-a3mhc8{background-color:#e6f7ff;color:#0050b3;padding:8px 12px;border-radius:4px;font-size:14px;display:flex;justify-content:space-between;align-items:center;width:100%;box-sizing:border-box;margin-bottom:8px;border:1px solid #91d5ff}.announcement a{color:#0050b3;font-weight:700;text-decoration:underline}.announcement a:hover{color:#003a8c}.vote-close-btn.svelte-a3mhc8{background-color:#b3d9ff;border:1px solid #0050b3;color:#0050b3;font-size:12px;cursor:pointer;padding:1px 10px;border-radius:4px;line-height:1;margin-left:5px;text-transform:none;transition:background-color .2s ease,color .2s ease,border-color .2s ease}.vote-close-btn.svelte-a3mhc8:hover,.vote-close-btn.svelte-a3mhc8:focus{background-color:#0050b3;color:#fff;border-color:#036;outline:none}a.svelte-a3mhc8{color:#188bd2}a.svelte-a3mhc8:hover{text-decoration:underline}.skill-icons--discord.svelte-a3mhc8{display:inline-block;width:1.2rem;height:1.2rem;margin-left:2px;background-repeat:no-repeat;background-size:100% 100%;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256'%3E%3Cg fill='none'%3E%3Crect width='256' height='256' fill='%235865f2' rx='60'/%3E%3Cg clip-path='url(%23skillIconsDiscord0)'%3E%3Cpath fill='%23ffffff' d='M197.308 64.797a165 165 0 0 0-40.709-12.627a.62.62 0 0 0-.654.31c-1.758 3.126-3.706 7.206-5.069 10.412c-15.373-2.302-30.666-2.302-45.723 0c-1.364-3.278-3.382-7.286-5.148-10.412a.64.64 0 0 0-.655-.31a164.5 164.5 0 0 0-40.709 12.627a.6.6 0 0 0-.268.23c-25.928 38.736-33.03 76.52-29.546 113.836a.7.7 0 0 0 .26.468c17.106 12.563 33.677 20.19 49.94 25.245a.65.65 0 0 0 .702-.23c3.847-5.254 7.276-10.793 10.217-16.618a.633.633 0 0 0-.347-.881c-5.44-2.064-10.619-4.579-15.601-7.436a.642.642 0 0 1-.063-1.064a86 86 0 0 0 3.098-2.428a.62.62 0 0 1 .646-.088c32.732 14.944 68.167 14.944 100.512 0a.62.62 0 0 1 .655.08a80 80 0 0 0 3.106 2.436a.642.642 0 0 1-.055 1.064a102.6 102.6 0 0 1-15.609 7.428a.64.64 0 0 0-.339.889a133 133 0 0 0 10.208 16.61a.64.64 0 0 0 .702.238c16.342-5.055 32.913-12.682 50.02-25.245a.65.65 0 0 0 .26-.46c4.17-43.141-6.985-80.616-29.571-113.836a.5.5 0 0 0-.26-.238M94.834 156.142c-9.855 0-17.975-9.047-17.975-20.158s7.963-20.158 17.975-20.158c10.09 0 18.131 9.127 17.973 20.158c0 11.111-7.962 20.158-17.973 20.158m66.456 0c-9.855 0-17.974-9.047-17.974-20.158s7.962-20.158 17.974-20.158c10.09 0 18.131 9.127 17.974 20.158c0 11.111-7.884 20.158-17.974 20.158'/%3E%3C/g%3E%3Cdefs%3E%3CclipPath id='skillIconsDiscord0'%3E%3Cpath fill='%23ffffff' d='M28 51h200v154.93H28z'/%3E%3C/clipPath%3E%3C/defs%3E%3C/g%3E%3C/svg%3E\")}.flat-color-icons--globe.svelte-a3mhc8{display:inline-block;width:1.2rem;height:1.2rem;margin-left:2px;background-repeat:no-repeat;background-size:100% 100%;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath fill='%237cb342' d='M24 4C13 4 4 13 4 24s9 20 20 20s20-9 20-20S35 4 24 4'/%3E%3Cpath fill='%230277bd' d='M45 24c0 11.7-9.5 21-21 21S3 35.7 3 24S12.3 3 24 3s21 9.3 21 21m-21.2 9.7c0-.4-.2-.6-.6-.8c-1.3-.4-2.5-.4-3.6-1.5c-.2-.4-.2-.8-.4-1.3c-.4-.4-1.5-.6-2.1-.8h-4.2c-.6-.2-1.1-1.1-1.5-1.7c0-.2 0-.6-.4-.6c-.4-.2-.8.2-1.3 0c-.2-.2-.2-.4-.2-.6c0-.6.4-1.3.8-1.7c.6-.4 1.3.2 1.9.2c.2 0 .2 0 .4.2c.6.2.8 1 .8 1.7v.4c0 .2.2.2.4.2c.2-1.1.2-2.1.4-3.2c0-1.3 1.3-2.5 2.3-2.9c.4-.2.6.2 1.1 0c1.3-.4 4.4-1.7 3.8-3.4c-.4-1.5-1.7-2.9-3.4-2.7c-.4.2-.6.4-1 .6c-.6.4-1.9 1.7-2.5 1.7c-1.1-.2-1.1-1.7-.8-2.3c.2-.8 2.1-3.6 3.4-3.1l.8.8c.4.2 1.1.2 1.7.2c.2 0 .4 0 .6-.2s.2-.2.2-.4c0-.6-.6-1.3-1-1.7s-1.1-.8-1.7-1.1c-2.1-.6-5.5.2-7.1 1.7s-2.9 4-3.8 6.1c-.4 1.3-.8 2.9-1 4.4c-.2 1-.4 1.9.2 2.9c.6 1.3 1.9 2.5 3.2 3.4c.8.6 2.5.6 3.4 1.7c.6.8.4 1.9.4 2.9c0 1.3.8 2.3 1.3 3.4c.2.6.4 1.5.6 2.1c0 .2.2 1.5.2 1.7c1.3.6 2.3 1.3 3.8 1.7c.2 0 1-1.3 1-1.5c.6-.6 1.1-1.5 1.7-1.9c.4-.2.8-.4 1.3-.8c.4-.4.6-1.3.8-1.9c.1-.5.3-1.3.1-1.9m.4-19.4c.2 0 .4-.2.8-.4c.6-.4 1.3-1.1 1.9-1.5s1.3-1.1 1.7-1.5c.6-.4 1.1-1.3 1.3-1.9c.2-.4.8-1.3.6-1.9c-.2-.4-1.3-.6-1.7-.8c-1.7-.4-3.1-.6-4.8-.6c-.6 0-1.5.2-1.7.8c-.2 1.1.6.8 1.5 1.1c0 0 .2 1.7.2 1.9c.2 1-.4 1.7-.4 2.7c0 .6 0 1.7.4 2.1zM41.8 29c.2-.4.2-1.1.4-1.5c.2-1 .2-2.1.2-3.1c0-2.1-.2-4.2-.8-6.1c-.4-.6-.6-1.3-.8-1.9c-.4-1.1-1-2.1-1.9-2.9c-.8-1.1-1.9-4-3.8-3.1c-.6.2-1 1-1.5 1.5c-.4.6-.8 1.3-1.3 1.9c-.2.2-.4.6-.2.8c0 .2.2.2.4.2c.4.2.6.2 1 .4c.2 0 .4.2.2.4c0 0 0 .2-.2.2c-1 1.1-2.1 1.9-3.1 2.9c-.2.2-.4.6-.4.8s.2.2.2.4s-.2.2-.4.4c-.4.2-.8.4-1.1.6c-.2.4 0 1.1-.2 1.5c-.2 1.1-.8 1.9-1.3 2.9c-.4.6-.6 1.3-1 1.9c0 .8-.2 1.5.2 2.1c1 1.5 2.9.6 4.4 1.3c.4.2.8.2 1.1.6c.6.6.6 1.7.8 2.3c.2.8.4 1.7.8 2.5c.2 1 .6 2.1.8 2.9c1.9-1.5 3.6-3.1 4.8-5.2c1.5-1.3 2.1-3 2.7-4.7'/%3E%3C/svg%3E\")}.skill-icons--list.svelte-a3mhc8{display:inline-block;width:1.2rem;height:1.2rem;margin-left:2px;background-repeat:no-repeat;background-size:100% 100%;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%235865f2' d='M4 3h13.17c.41 0 .8.16 1.09.44l3.3 3.3c.29.29.44.68.44 1.09V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z'/%3E%3Cpath fill='%23ffffff' d='M14 2v4h4l-4-4zM7 9h10v2H7V9zm0 4h7v2H7v-2z'/%3E%3C/svg%3E\")}.question-mark-icon.svelte-a3mhc8{display:inline-block;width:1.2rem;height:1.2rem;margin-left:2px;background-repeat:no-repeat;background-size:100% 100%;background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23188bd2' d='M21 2H3c-.55 0-1 .45-1 1v18c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1ZM12 18a1 1 0 1 1 1-1a1 1 0 0 1-1 1Zm2.07-5.25c-.9.52-.98 1.26-.98 1.75h-2c0-1.12.46-2.21 1.78-2.91c.9-.52 1.22-.87 1.22-1.34a1.5 1.5 0 0 0-3 0H9a3.5 3.5 0 0 1 7 0c0 1.63-1.28 2.41-1.93 2.75Z'/%3E%3C/svg%3E\");cursor:pointer}.icons.svelte-a3mhc8{display:inline-block;vertical-align:middle}.flex.svelte-a3mhc8{display:flex;align-items:center}.icons.svelte-a3mhc8 a:where(.svelte-a3mhc8) span:where(.svelte-a3mhc8){align-items:center;justify-content:center}hr.svelte-a3mhc8{border:0;border-top:1px solid white;width:100%}.header.svelte-a3mhc8{cursor:move;border-bottom:1px solid #aaa;width:100%;display:flex;justify-content:space-between;align-items:center;touch-action:none;-webkit-user-select:none;user-select:none}.geometa-note a{color:#188bd2}.geometa-note a:hover{text-decoration:underline}.geometa-note ul li{list-style-type:disc;margin-left:1rem}.geometa-note ol li{list-style-type:decimal;margin-left:1rem}.modal-backdrop.svelte-a3mhc8{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#1e1e1ecc;display:flex;justify-content:center;align-items:center;z-index:1000}.modal.svelte-a3mhc8{background:var(--ds-color-purple-100);padding:15px 25px;border-radius:8px;text-align:center;width:90%;max-width:600px;box-shadow:0 4px 6px #0003;color:#d3d3d3}.modal.svelte-a3mhc8 p:where(.svelte-a3mhc8){margin:0 0 10px;font-size:17px}.modal-url.svelte-a3mhc8{font-size:15px;font-weight:700;color:#188bd2;word-break:break-word;margin:10px 0}.modal-buttons.svelte-a3mhc8{display:flex;justify-content:center;gap:15px;margin-top:20px}.proceed-btn.svelte-a3mhc8{background:#188bd2;color:#fff;padding:8px 16px;border:none;border-radius:5px;cursor:pointer;font-size:15px;transition:background-color .2s ease-in-out}.proceed-btn.svelte-a3mhc8:hover{background:#0056b3}.close-btn.svelte-a3mhc8{background:transparent;color:#d3d3d3;padding:8px 16px;border:1px solid #d3d3d3;border-radius:5px;cursor:pointer;font-size:15px;transition:background-color .2s ease-in-out,color .2s ease-in-out}.close-btn.svelte-a3mhc8:hover{background:#d3d3d3;color:var(--ds-color-purple-100)}button.svelte-a3mhc8{cursor:pointer;background:none;border:none;padding:0}.blink.svelte-a3mhc8{animation:svelte-a3mhc8-blink-animation 1s infinite}.help-message.svelte-a3mhc8{padding:12px;font-size:16px;line-height:1.5;text-align:left}.help-message.svelte-a3mhc8 strong:where(.svelte-a3mhc8){color:#007bff;font-weight:700}@keyframes svelte-a3mhc8-blink-animation{0%{filter:brightness(1)}50%{filter:brightness(2);background-color:#004779}to{filter:brightness(1)}}.outdated.svelte-a3mhc8 strong:where(.svelte-a3mhc8){color:red!important}.geometa-meta-btn{background:#188bd2;color:#fff;border:none;border-radius:3px;padding:2px 6px;font-size:11px;cursor:pointer;margin-left:10px;transition:background-color .2s ease;font-weight:700;z-index:1000;pointer-events:auto;display:inline-block}.result-list_listItemWrapper___XCGn{display:flex!important;justify-content:space-between!important;align-items:center!important}.geometa-meta-btn:hover{background:#0056b3}.geometa-pin-question{position:absolute;top:-8px;right:-8px;width:16px;height:16px;background:#188bd2;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:700;cursor:pointer;z-index:10000;transition:background-color .2s ease;border:1px solid white;box-shadow:0 1px 3px #0000004d}.geometa-pin-question:hover{background:#0056b3;transform:scale(1.1)}.geometa-map-label-container.svelte-1mmcvqu{background-color:#0003;color:#fff;text-align:center;z-index:999999;position:absolute;bottom:4px;right:4px;box-sizing:border-box;border-radius:8px;padding:8px;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);display:flex;align-items:center;gap:8px;text-shadow:0 0 10px rgba(255,255,255,.1)}p.svelte-1mmcvqu{font-size:14px;font-weight:700}button.svelte-1mmcvqu{padding:6px 12px;font-size:12px;color:#fff;background-color:#4caf50;border:none;border-radius:4px;cursor:pointer}.toast-notification.svelte-1rq8lsd{z-index:10001;min-width:250px;max-width:400px;padding:14px 22px;border-radius:8px;box-shadow:0 5px 15px #0003;color:#fff;display:flex;align-items:center;justify-content:space-between;font-size:.95em;line-height:1.4}.toast-success.svelte-1rq8lsd{background-color:#28a745;border-left:5px solid #1e7e34}.toast-error.svelte-1rq8lsd{background-color:#dc3545;border-left:5px solid #b02a37}.toast-info.svelte-1rq8lsd{background-color:#17a2b8;border-left:5px solid #117a8b}.toast-warning.svelte-1rq8lsd{background-color:#ffc107;color:#212529;border-left:5px solid #d39e00}.toast-message.svelte-1rq8lsd{flex-grow:1;margin-right:10px}.toast-close-button.svelte-1rq8lsd{background:transparent;border:none;color:inherit;font-size:1.6em;font-weight:700;margin-left:10px;cursor:pointer;padding:0;line-height:1;opacity:.7;transition:opacity .2s ease}.toast-close-button.svelte-1rq8lsd:hover{opacity:1}.custom-yellow-button.svelte-17or0cf{background:linear-gradient(180deg,#ffeb99,#f5c542);border:1px solid #e0b000;color:#002147;border-radius:3.75rem;box-shadow:0 2px 4px #00000026,inset 0 1px #fff6;cursor:pointer;transition:background .2s ease-in-out,transform .1s ease,box-shadow .2s ease-in-out}.custom-yellow-button.svelte-17or0cf:hover:not(:where(.svelte-17or0cf):disabled){background:linear-gradient(180deg,#ffe066,#eab308);box-shadow:0 4px 8px #0003,inset 0 1px #ffffff80;transform:translateY(-1px)}.custom-yellow-button.svelte-17or0cf:active:not(:where(.svelte-17or0cf):disabled){background:linear-gradient(180deg,#eab308,#d39e00);box-shadow:0 2px 4px #0003 inset;transform:translateY(1px)}.custom-yellow-button.svelte-17or0cf:focus{outline:none;box-shadow:0 0 0 3px #eab30880,0 2px 4px #00000026}.custom-yellow-button.svelte-17or0cf:disabled{background:#e0e0e0;border-color:#bbb;color:#888;box-shadow:none;cursor:not-allowed;transform:none}.modal-overlay.svelte-17or0cf{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#0009;display:flex;justify-content:center;align-items:center;z-index:10000}.modal-content.svelte-17or0cf{background-color:#fff;padding:25px 30px;border-radius:8px;box-shadow:0 5px 15px #0000004d;width:90%;max-width:450px;color:#333}.modal-content.svelte-17or0cf h2:where(.svelte-17or0cf){margin-top:0;margin-bottom:15px;color:#2c3e50}.modal-content.svelte-17or0cf p:where(.svelte-17or0cf){margin-bottom:15px;line-height:1.6}.modal-content.svelte-17or0cf p:where(.svelte-17or0cf) a:where(.svelte-17or0cf){color:#007bff;text-decoration:underline}.modal-content.svelte-17or0cf p:where(.svelte-17or0cf) a:where(.svelte-17or0cf):hover{color:#0056b3}.modal-input.svelte-17or0cf{width:calc(100% - 20px);padding:10px;margin-bottom:20px;border:1px solid #ccc;border-radius:4px;font-size:1em}.modal-actions.svelte-17or0cf{display:flex;justify-content:flex-end;gap:10px}.modal-button.svelte-17or0cf{padding:10px 18px;border:none;border-radius:4px;cursor:pointer;font-weight:700;transition:background-color .2s ease}.modal-button-save.svelte-17or0cf{background-color:#28a745;color:#fff}.modal-button-save.svelte-17or0cf:hover{background-color:#218838}.modal-button-cancel.svelte-17or0cf{background-color:#6c757d;color:#fff}.modal-button-cancel.svelte-17or0cf:hover{background-color:#5a6268}.modal-note.svelte-17or0cf{font-size:.85em;color:#555;margin-top:15px;text-align:center} `);\n\n(async function () {\n  'use strict';\n\n  var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != \"undefined\" ? GM_getValue : void 0)();\n  var _GM_info = /* @__PURE__ */ (() => typeof GM_info != \"undefined\" ? GM_info : void 0)();\n  var _GM_registerMenuCommand = /* @__PURE__ */ (() => typeof GM_registerMenuCommand != \"undefined\" ? GM_registerMenuCommand : void 0)();\n  var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != \"undefined\" ? GM_setValue : void 0)();\n  var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != \"undefined\" ? GM_xmlhttpRequest : void 0)();\n  var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != \"undefined\" ? unsafeWindow : void 0)();\n  function waitForElement(selector) {\n    return new Promise((resolve) => {\n      try {\n        const existingElement = document.querySelector(selector);\n        if (existingElement) {\n          resolve(existingElement);\n          return;\n        }\n      } catch {\n      }\n      const observer = new MutationObserver(() => {\n        try {\n          const element = document.querySelector(selector);\n          if (element) {\n            observer.disconnect();\n            removeUrlChangeListener();\n            resolve(element);\n            return;\n          }\n        } catch {\n        }\n      });\n      const handleUrlChange = () => {\n        observer.disconnect();\n        removeUrlChangeListener();\n        resolve(null);\n      };\n      const removeUrlChangeListener = () => {\n        window.removeEventListener(\"urlchange\", handleUrlChange);\n      };\n      window.addEventListener(\"urlchange\", handleUrlChange);\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [\"class\"]\n      });\n    });\n  }\n  function localStorageGetInt(name) {\n    const savedValue = _unsafeWindow.localStorage.getItem(name);\n    if (!savedValue) {\n      return null;\n    }\n    const savedInt = parseInt(savedValue, 10);\n    if (isNaN(savedInt)) {\n      return null;\n    }\n    return savedInt;\n  }\n  async function fetchMapInfo(url) {\n    return new Promise((resolve, reject) => {\n      _GM_xmlhttpRequest({\n        method: \"GET\",\n        url,\n        onload: (response) => {\n          if (response.status === 200 || response.status === 404) {\n            try {\n              const mapInfo = JSON.parse(response.responseText);\n              logInfo(\"fetched map info\", mapInfo);\n              resolve(mapInfo);\n            } catch (e) {\n              logInfo(\"failed to parse map info response\", e);\n              reject(\"Failed to parse response\");\n            }\n          } else {\n            logInfo(\"failed to fetch map info\", response);\n            reject(`HTTP error! status: ${response.status}`);\n          }\n        },\n        onerror: () => {\n          reject(\"An error occurred while fetching data\");\n        }\n      });\n    });\n  }\n  async function getMapInfo(geoguessrId, forceUpdate) {\n    const localStorageMapInfoKey = `geometa:map-info:${geoguessrId}`;\n    if (!forceUpdate) {\n      const savedMapInfo = _unsafeWindow.localStorage.getItem(localStorageMapInfoKey);\n      if (savedMapInfo) {\n        const mapInfo2 = JSON.parse(savedMapInfo);\n        logInfo(\"using saved map info\", mapInfo2);\n        return mapInfo2;\n      }\n    }\n    const url = `https://learnablemeta.com/api/userscript/map/${geoguessrId}`;\n    const mapInfo = await fetchMapInfo(url);\n    _unsafeWindow.localStorage.setItem(localStorageMapInfoKey, JSON.stringify(mapInfo));\n    _unsafeWindow.localStorage.setItem(\"geometa:latest-version\", mapInfo.userscriptVersion);\n    return mapInfo;\n  }\n  function getLatestVersionInfo() {\n    return _unsafeWindow.localStorage.getItem(\"geometa:latest-version\");\n  }\n  function checkIfOutdated() {\n    return _GM_info.script.version != getLatestVersionInfo();\n  }\n  function markHelpMessageAsRead() {\n    _unsafeWindow.localStorage.setItem(\"geometa:help-message-read\", \"true\");\n  }\n  function wasHelpMessageRead() {\n    return _unsafeWindow.localStorage.getItem(\"geometa:help-message-read\") == \"true\";\n  }\n  const getChallengeId = () => {\n    const regexp = /.*\\/live-challenge\\/(.*)/;\n    const matches = location.pathname.match(regexp);\n    if (matches && matches.length > 1) {\n      return matches[1];\n    }\n    return null;\n  };\n  async function getChallengeInfo(id) {\n    const url = `https://game-server.geoguessr.com/api/live-challenge/${id}`;\n    const response = await fetch(url, {\n      method: \"GET\",\n      credentials: \"include\"\n    });\n    const data = await response.json();\n    const mapId = data.options.mapSlug;\n    const currentRound = data.currentRoundNumber - 1;\n    const rounds = data.rounds;\n    const panorama = rounds[currentRound].question.panoramaQuestionPayload.panorama;\n    const panoIdHex = panorama.panoId;\n    const panoId = decodePanoId(panoIdHex);\n    return { mapId, panoId };\n  }\n  function decodePanoId(encoded) {\n    const len = Math.floor(encoded.length / 2);\n    let panoId = [];\n    for (let i = 0; i < len; i++) {\n      const code = parseInt(encoded.slice(i * 2, i * 2 + 2), 16);\n      const char = String.fromCharCode(code);\n      panoId = [...panoId, char];\n    }\n    return panoId.join(\"\");\n  }\n  function logInfo(name, data) {\n    console.log(`ALM: ${name}`, data);\n  }\n  function extractMapIdFromUrl(url) {\n    const match = url.match(/\\/maps\\/([^\\/]+)/);\n    return match ? match[1] : null;\n  }\n  const DEV = false;\n  var is_array = Array.isArray;\n  var array_from = Array.from;\n  var define_property = Object.defineProperty;\n  var get_descriptor = Object.getOwnPropertyDescriptor;\n  var get_descriptors = Object.getOwnPropertyDescriptors;\n  var object_prototype = Object.prototype;\n  var array_prototype = Array.prototype;\n  var get_prototype_of = Object.getPrototypeOf;\n  function is_function(thing) {\n    return typeof thing === \"function\";\n  }\n  const noop = () => {\n  };\n  function is_promise(value) {\n    return typeof (value == null ? void 0 : value.then) === \"function\";\n  }\n  function run(fn) {\n    return fn();\n  }\n  function run_all(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      arr[i]();\n    }\n  }\n  const DERIVED = 1 << 1;\n  const EFFECT = 1 << 2;\n  const RENDER_EFFECT = 1 << 3;\n  const BLOCK_EFFECT = 1 << 4;\n  const BRANCH_EFFECT = 1 << 5;\n  const ROOT_EFFECT = 1 << 6;\n  const UNOWNED = 1 << 7;\n  const DISCONNECTED = 1 << 8;\n  const CLEAN = 1 << 9;\n  const DIRTY = 1 << 10;\n  const MAYBE_DIRTY = 1 << 11;\n  const INERT = 1 << 12;\n  const DESTROYED = 1 << 13;\n  const EFFECT_RAN = 1 << 14;\n  const EFFECT_TRANSPARENT = 1 << 15;\n  const LEGACY_DERIVED_PROP = 1 << 16;\n  const HEAD_EFFECT = 1 << 18;\n  const EFFECT_HAS_DERIVED = 1 << 19;\n  const STATE_SYMBOL = Symbol(\"$state\");\n  const LOADING_ATTR_SYMBOL = Symbol(\"\");\n  function equals(value) {\n    return value === this.v;\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a !== null && typeof a === \"object\" || typeof a === \"function\";\n  }\n  function safe_equals(value) {\n    return !safe_not_equal(value, this.v);\n  }\n  function effect_in_teardown(rune) {\n    {\n      throw new Error(\"effect_in_teardown\");\n    }\n  }\n  function effect_in_unowned_derived() {\n    {\n      throw new Error(\"effect_in_unowned_derived\");\n    }\n  }\n  function effect_orphan(rune) {\n    {\n      throw new Error(\"effect_orphan\");\n    }\n  }\n  function effect_update_depth_exceeded() {\n    {\n      throw new Error(\"effect_update_depth_exceeded\");\n    }\n  }\n  function props_invalid_value(key) {\n    {\n      throw new Error(\"props_invalid_value\");\n    }\n  }\n  function state_descriptors_fixed() {\n    {\n      throw new Error(\"state_descriptors_fixed\");\n    }\n  }\n  function state_prototype_fixed() {\n    {\n      throw new Error(\"state_prototype_fixed\");\n    }\n  }\n  function state_unsafe_local_read() {\n    {\n      throw new Error(\"state_unsafe_local_read\");\n    }\n  }\n  function state_unsafe_mutation() {\n    {\n      throw new Error(\"state_unsafe_mutation\");\n    }\n  }\n  function source(v) {\n    return {\n      f: 0,\n      // TODO ideally we could skip this altogether, but it causes type errors\n      v,\n      reactions: null,\n      equals,\n      version: 0\n    };\n  }\n  function state(v) {\n    return /* @__PURE__ */ push_derived_source(source(v));\n  }\n  // @__NO_SIDE_EFFECTS__\n  function mutable_source(initial_value, immutable = false) {\n    var _a;\n    const s = source(initial_value);\n    if (!immutable) {\n      s.equals = safe_equals;\n    }\n    if (component_context !== null && component_context.l !== null) {\n      ((_a = component_context.l).s ?? (_a.s = [])).push(s);\n    }\n    return s;\n  }\n  function mutable_state(v, immutable = false) {\n    return /* @__PURE__ */ push_derived_source(/* @__PURE__ */ mutable_source(v, immutable));\n  }\n  // @__NO_SIDE_EFFECTS__\n  function push_derived_source(source2) {\n    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n      if (derived_sources === null) {\n        set_derived_sources([source2]);\n      } else {\n        derived_sources.push(source2);\n      }\n    }\n    return source2;\n  }\n  function set(source2, value) {\n    if (active_reaction !== null && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && // If the source was created locally within the current derived, then\n    // we allow the mutation.\n    (derived_sources === null || !derived_sources.includes(source2))) {\n      state_unsafe_mutation();\n    }\n    return internal_set(source2, value);\n  }\n  function internal_set(source2, value) {\n    if (!source2.equals(value)) {\n      source2.v = value;\n      source2.version = increment_version();\n      mark_reactions(source2, DIRTY);\n      if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0) {\n        if (new_deps !== null && new_deps.includes(source2)) {\n          set_signal_status(active_effect, DIRTY);\n          schedule_effect(active_effect);\n        } else {\n          if (untracked_writes === null) {\n            set_untracked_writes([source2]);\n          } else {\n            untracked_writes.push(source2);\n          }\n        }\n      }\n    }\n    return value;\n  }\n  function mark_reactions(signal, status) {\n    var reactions = signal.reactions;\n    if (reactions === null) return;\n    var runes = is_runes();\n    var length = reactions.length;\n    for (var i = 0; i < length; i++) {\n      var reaction = reactions[i];\n      var flags = reaction.f;\n      if ((flags & DIRTY) !== 0) continue;\n      if (!runes && reaction === active_effect) continue;\n      set_signal_status(reaction, status);\n      if ((flags & (CLEAN | UNOWNED)) !== 0) {\n        if ((flags & DERIVED) !== 0) {\n          mark_reactions(\n            /** @type {Derived} */\n            reaction,\n            MAYBE_DIRTY\n          );\n        } else {\n          schedule_effect(\n            /** @type {Effect} */\n            reaction\n          );\n        }\n      }\n    }\n  }\n  const EACH_ITEM_REACTIVE = 1;\n  const EACH_INDEX_REACTIVE = 1 << 1;\n  const EACH_IS_CONTROLLED = 1 << 2;\n  const EACH_IS_ANIMATED = 1 << 3;\n  const EACH_ITEM_IMMUTABLE = 1 << 4;\n  const PROPS_IS_IMMUTABLE = 1;\n  const PROPS_IS_RUNES = 1 << 1;\n  const PROPS_IS_UPDATED = 1 << 2;\n  const PROPS_IS_BINDABLE = 1 << 3;\n  const PROPS_IS_LAZY_INITIAL = 1 << 4;\n  const TRANSITION_IN = 1;\n  const TRANSITION_OUT = 1 << 1;\n  const TRANSITION_GLOBAL = 1 << 2;\n  const TEMPLATE_FRAGMENT = 1;\n  const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n  const UNINITIALIZED = Symbol();\n  let hydrating = false;\n  function proxy(value, parent = null, prev2) {\n    if (typeof value !== \"object\" || value === null || STATE_SYMBOL in value) {\n      return value;\n    }\n    const prototype = get_prototype_of(value);\n    if (prototype !== object_prototype && prototype !== array_prototype) {\n      return value;\n    }\n    var sources = /* @__PURE__ */ new Map();\n    var is_proxied_array = is_array(value);\n    var version = source(0);\n    if (is_proxied_array) {\n      sources.set(\"length\", source(\n        /** @type {any[]} */\n        value.length\n      ));\n    }\n    var metadata;\n    return new Proxy(\n      /** @type {any} */\n      value,\n      {\n        defineProperty(_, prop2, descriptor) {\n          if (!(\"value\" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {\n            state_descriptors_fixed();\n          }\n          var s = sources.get(prop2);\n          if (s === void 0) {\n            s = source(descriptor.value);\n            sources.set(prop2, s);\n          } else {\n            set(s, proxy(descriptor.value, metadata));\n          }\n          return true;\n        },\n        deleteProperty(target, prop2) {\n          var s = sources.get(prop2);\n          if (s === void 0) {\n            if (prop2 in target) {\n              sources.set(prop2, source(UNINITIALIZED));\n            }\n          } else {\n            if (is_proxied_array && typeof prop2 === \"string\") {\n              var ls = (\n                /** @type {Source<number>} */\n                sources.get(\"length\")\n              );\n              var n = Number(prop2);\n              if (Number.isInteger(n) && n < ls.v) {\n                set(ls, n);\n              }\n            }\n            set(s, UNINITIALIZED);\n            update_version(version);\n          }\n          return true;\n        },\n        get(target, prop2, receiver) {\n          var _a;\n          if (prop2 === STATE_SYMBOL) {\n            return value;\n          }\n          var s = sources.get(prop2);\n          var exists = prop2 in target;\n          if (s === void 0 && (!exists || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {\n            s = source(proxy(exists ? target[prop2] : UNINITIALIZED, metadata));\n            sources.set(prop2, s);\n          }\n          if (s !== void 0) {\n            var v = get(s);\n            return v === UNINITIALIZED ? void 0 : v;\n          }\n          return Reflect.get(target, prop2, receiver);\n        },\n        getOwnPropertyDescriptor(target, prop2) {\n          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);\n          if (descriptor && \"value\" in descriptor) {\n            var s = sources.get(prop2);\n            if (s) descriptor.value = get(s);\n          } else if (descriptor === void 0) {\n            var source2 = sources.get(prop2);\n            var value2 = source2 == null ? void 0 : source2.v;\n            if (source2 !== void 0 && value2 !== UNINITIALIZED) {\n              return {\n                enumerable: true,\n                configurable: true,\n                value: value2,\n                writable: true\n              };\n            }\n          }\n          return descriptor;\n        },\n        has(target, prop2) {\n          var _a;\n          if (prop2 === STATE_SYMBOL) {\n            return true;\n          }\n          var s = sources.get(prop2);\n          var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);\n          if (s !== void 0 || active_effect !== null && (!has || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {\n            if (s === void 0) {\n              s = source(has ? proxy(target[prop2], metadata) : UNINITIALIZED);\n              sources.set(prop2, s);\n            }\n            var value2 = get(s);\n            if (value2 === UNINITIALIZED) {\n              return false;\n            }\n          }\n          return has;\n        },\n        set(target, prop2, value2, receiver) {\n          var _a;\n          var s = sources.get(prop2);\n          var has = prop2 in target;\n          if (is_proxied_array && prop2 === \"length\") {\n            for (var i = value2; i < /** @type {Source<number>} */\n            s.v; i += 1) {\n              var other_s = sources.get(i + \"\");\n              if (other_s !== void 0) {\n                set(other_s, UNINITIALIZED);\n              } else if (i in target) {\n                other_s = source(UNINITIALIZED);\n                sources.set(i + \"\", other_s);\n              }\n            }\n          }\n          if (s === void 0) {\n            if (!has || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable)) {\n              s = source(void 0);\n              set(s, proxy(value2, metadata));\n              sources.set(prop2, s);\n            }\n          } else {\n            has = s.v !== UNINITIALIZED;\n            set(s, proxy(value2, metadata));\n          }\n          var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);\n          if (descriptor == null ? void 0 : descriptor.set) {\n            descriptor.set.call(receiver, value2);\n          }\n          if (!has) {\n            if (is_proxied_array && typeof prop2 === \"string\") {\n              var ls = (\n                /** @type {Source<number>} */\n                sources.get(\"length\")\n              );\n              var n = Number(prop2);\n              if (Number.isInteger(n) && n >= ls.v) {\n                set(ls, n + 1);\n              }\n            }\n            update_version(version);\n          }\n          return true;\n        },\n        ownKeys(target) {\n          get(version);\n          var own_keys = Reflect.ownKeys(target).filter((key2) => {\n            var source3 = sources.get(key2);\n            return source3 === void 0 || source3.v !== UNINITIALIZED;\n          });\n          for (var [key, source2] of sources) {\n            if (source2.v !== UNINITIALIZED && !(key in target)) {\n              own_keys.push(key);\n            }\n          }\n          return own_keys;\n        },\n        setPrototypeOf() {\n          state_prototype_fixed();\n        }\n      }\n    );\n  }\n  function update_version(signal, d = 1) {\n    set(signal, signal.v + d);\n  }\n  var $window;\n  var first_child_getter;\n  var next_sibling_getter;\n  function init_operations() {\n    if ($window !== void 0) {\n      return;\n    }\n    $window = window;\n    var element_prototype = Element.prototype;\n    var node_prototype = Node.prototype;\n    first_child_getter = get_descriptor(node_prototype, \"firstChild\").get;\n    next_sibling_getter = get_descriptor(node_prototype, \"nextSibling\").get;\n    element_prototype.__click = void 0;\n    element_prototype.__className = \"\";\n    element_prototype.__attributes = null;\n    element_prototype.__styles = null;\n    element_prototype.__e = void 0;\n    Text.prototype.__t = void 0;\n  }\n  function create_text(value = \"\") {\n    return document.createTextNode(value);\n  }\n  // @__NO_SIDE_EFFECTS__\n  function get_first_child(node) {\n    return first_child_getter.call(node);\n  }\n  // @__NO_SIDE_EFFECTS__\n  function get_next_sibling(node) {\n    return next_sibling_getter.call(node);\n  }\n  function child(node, is_text) {\n    {\n      return /* @__PURE__ */ get_first_child(node);\n    }\n  }\n  function first_child(fragment, is_text) {\n    {\n      var first = (\n        /** @type {DocumentFragment} */\n        /* @__PURE__ */ get_first_child(\n          /** @type {Node} */\n          fragment\n        )\n      );\n      if (first instanceof Comment && first.data === \"\") return /* @__PURE__ */ get_next_sibling(first);\n      return first;\n    }\n  }\n  function sibling(node, count = 1, is_text = false) {\n    let next_sibling = node;\n    while (count--) {\n      next_sibling = /** @type {TemplateNode} */\n      /* @__PURE__ */ get_next_sibling(next_sibling);\n    }\n    {\n      return next_sibling;\n    }\n  }\n  function clear_text_content(node) {\n    node.textContent = \"\";\n  }\n  // @__NO_SIDE_EFFECTS__\n  function derived(fn) {\n    var flags = DERIVED | DIRTY;\n    if (active_effect === null) {\n      flags |= UNOWNED;\n    } else {\n      active_effect.f |= EFFECT_HAS_DERIVED;\n    }\n    const signal = {\n      children: null,\n      ctx: component_context,\n      deps: null,\n      equals,\n      f: flags,\n      fn,\n      reactions: null,\n      v: (\n        /** @type {V} */\n        null\n      ),\n      version: 0,\n      parent: active_effect\n    };\n    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n      var derived2 = (\n        /** @type {Derived} */\n        active_reaction\n      );\n      (derived2.children ?? (derived2.children = [])).push(signal);\n    }\n    return signal;\n  }\n  // @__NO_SIDE_EFFECTS__\n  function derived_safe_equal(fn) {\n    const signal = /* @__PURE__ */ derived(fn);\n    signal.equals = safe_equals;\n    return signal;\n  }\n  function destroy_derived_children(derived2) {\n    var children = derived2.children;\n    if (children !== null) {\n      derived2.children = null;\n      for (var i = 0; i < children.length; i += 1) {\n        var child2 = children[i];\n        if ((child2.f & DERIVED) !== 0) {\n          destroy_derived(\n            /** @type {Derived} */\n            child2\n          );\n        } else {\n          destroy_effect(\n            /** @type {Effect} */\n            child2\n          );\n        }\n      }\n    }\n  }\n  function execute_derived(derived2) {\n    var value;\n    var prev_active_effect = active_effect;\n    set_active_effect(derived2.parent);\n    {\n      try {\n        destroy_derived_children(derived2);\n        value = update_reaction(derived2);\n      } finally {\n        set_active_effect(prev_active_effect);\n      }\n    }\n    return value;\n  }\n  function update_derived(derived2) {\n    var value = execute_derived(derived2);\n    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;\n    set_signal_status(derived2, status);\n    if (!derived2.equals(value)) {\n      derived2.v = value;\n      derived2.version = increment_version();\n    }\n  }\n  function destroy_derived(signal) {\n    destroy_derived_children(signal);\n    remove_reactions(signal, 0);\n    set_signal_status(signal, DESTROYED);\n    signal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;\n  }\n  function validate_effect(rune) {\n    if (active_effect === null && active_reaction === null) {\n      effect_orphan();\n    }\n    if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {\n      effect_in_unowned_derived();\n    }\n    if (is_destroying_effect) {\n      effect_in_teardown();\n    }\n  }\n  function push_effect(effect2, parent_effect) {\n    var parent_last = parent_effect.last;\n    if (parent_last === null) {\n      parent_effect.last = parent_effect.first = effect2;\n    } else {\n      parent_last.next = effect2;\n      effect2.prev = parent_last;\n      parent_effect.last = effect2;\n    }\n  }\n  function create_effect(type, fn, sync, push2 = true) {\n    var is_root = (type & ROOT_EFFECT) !== 0;\n    var parent_effect = active_effect;\n    var effect2 = {\n      ctx: component_context,\n      deps: null,\n      deriveds: null,\n      nodes_start: null,\n      nodes_end: null,\n      f: type | DIRTY,\n      first: null,\n      fn,\n      last: null,\n      next: null,\n      parent: is_root ? null : parent_effect,\n      prev: null,\n      teardown: null,\n      transitions: null,\n      version: 0\n    };\n    if (sync) {\n      var previously_flushing_effect = is_flushing_effect;\n      try {\n        set_is_flushing_effect(true);\n        update_effect(effect2);\n        effect2.f |= EFFECT_RAN;\n      } catch (e) {\n        destroy_effect(effect2);\n        throw e;\n      } finally {\n        set_is_flushing_effect(previously_flushing_effect);\n      }\n    } else if (fn !== null) {\n      schedule_effect(effect2);\n    }\n    var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & EFFECT_HAS_DERIVED) === 0;\n    if (!inert && !is_root && push2) {\n      if (parent_effect !== null) {\n        push_effect(effect2, parent_effect);\n      }\n      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n        var derived2 = (\n          /** @type {Derived} */\n          active_reaction\n        );\n        (derived2.children ?? (derived2.children = [])).push(effect2);\n      }\n    }\n    return effect2;\n  }\n  function teardown(fn) {\n    const effect2 = create_effect(RENDER_EFFECT, null, false);\n    set_signal_status(effect2, CLEAN);\n    effect2.teardown = fn;\n    return effect2;\n  }\n  function user_effect(fn) {\n    validate_effect();\n    var defer = active_effect !== null && (active_effect.f & BRANCH_EFFECT) !== 0 && component_context !== null && !component_context.m;\n    if (defer) {\n      var context = (\n        /** @type {ComponentContext} */\n        component_context\n      );\n      (context.e ?? (context.e = [])).push({\n        fn,\n        effect: active_effect,\n        reaction: active_reaction\n      });\n    } else {\n      var signal = effect(fn);\n      return signal;\n    }\n  }\n  function user_pre_effect(fn) {\n    validate_effect();\n    return render_effect(fn);\n  }\n  function effect_root(fn) {\n    const effect2 = create_effect(ROOT_EFFECT, fn, true);\n    return () => {\n      destroy_effect(effect2);\n    };\n  }\n  function effect(fn) {\n    return create_effect(EFFECT, fn, false);\n  }\n  function render_effect(fn) {\n    return create_effect(RENDER_EFFECT, fn, true);\n  }\n  function template_effect(fn) {\n    return block(fn);\n  }\n  function block(fn, flags = 0) {\n    return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n  }\n  function branch(fn, push2 = true) {\n    return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push2);\n  }\n  function execute_effect_teardown(effect2) {\n    var teardown2 = effect2.teardown;\n    if (teardown2 !== null) {\n      const previously_destroying_effect = is_destroying_effect;\n      const previous_reaction = active_reaction;\n      set_is_destroying_effect(true);\n      set_active_reaction(null);\n      try {\n        teardown2.call(null);\n      } finally {\n        set_is_destroying_effect(previously_destroying_effect);\n        set_active_reaction(previous_reaction);\n      }\n    }\n  }\n  function destroy_effect_deriveds(signal) {\n    var deriveds = signal.deriveds;\n    if (deriveds !== null) {\n      signal.deriveds = null;\n      for (var i = 0; i < deriveds.length; i += 1) {\n        destroy_derived(deriveds[i]);\n      }\n    }\n  }\n  function destroy_effect_children(signal, remove_dom = false) {\n    var effect2 = signal.first;\n    signal.first = signal.last = null;\n    while (effect2 !== null) {\n      var next2 = effect2.next;\n      destroy_effect(effect2, remove_dom);\n      effect2 = next2;\n    }\n  }\n  function destroy_block_effect_children(signal) {\n    var effect2 = signal.first;\n    while (effect2 !== null) {\n      var next2 = effect2.next;\n      if ((effect2.f & BRANCH_EFFECT) === 0) {\n        destroy_effect(effect2);\n      }\n      effect2 = next2;\n    }\n  }\n  function destroy_effect(effect2, remove_dom = true) {\n    var removed = false;\n    if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null) {\n      var node = effect2.nodes_start;\n      var end = effect2.nodes_end;\n      while (node !== null) {\n        var next2 = node === end ? null : (\n          /** @type {TemplateNode} */\n          /* @__PURE__ */ get_next_sibling(node)\n        );\n        node.remove();\n        node = next2;\n      }\n      removed = true;\n    }\n    destroy_effect_deriveds(effect2);\n    destroy_effect_children(effect2, remove_dom && !removed);\n    remove_reactions(effect2, 0);\n    set_signal_status(effect2, DESTROYED);\n    var transitions = effect2.transitions;\n    if (transitions !== null) {\n      for (const transition2 of transitions) {\n        transition2.stop();\n      }\n    }\n    execute_effect_teardown(effect2);\n    var parent = effect2.parent;\n    if (parent !== null && parent.first !== null) {\n      unlink_effect(effect2);\n    }\n    effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.parent = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;\n  }\n  function unlink_effect(effect2) {\n    var parent = effect2.parent;\n    var prev2 = effect2.prev;\n    var next2 = effect2.next;\n    if (prev2 !== null) prev2.next = next2;\n    if (next2 !== null) next2.prev = prev2;\n    if (parent !== null) {\n      if (parent.first === effect2) parent.first = next2;\n      if (parent.last === effect2) parent.last = prev2;\n    }\n  }\n  function pause_effect(effect2, callback) {\n    var transitions = [];\n    pause_children(effect2, transitions, true);\n    run_out_transitions(transitions, () => {\n      destroy_effect(effect2);\n      if (callback) callback();\n    });\n  }\n  function run_out_transitions(transitions, fn) {\n    var remaining = transitions.length;\n    if (remaining > 0) {\n      var check = () => --remaining || fn();\n      for (var transition2 of transitions) {\n        transition2.out(check);\n      }\n    } else {\n      fn();\n    }\n  }\n  function pause_children(effect2, transitions, local) {\n    if ((effect2.f & INERT) !== 0) return;\n    effect2.f ^= INERT;\n    if (effect2.transitions !== null) {\n      for (const transition2 of effect2.transitions) {\n        if (transition2.is_global || local) {\n          transitions.push(transition2);\n        }\n      }\n    }\n    var child2 = effect2.first;\n    while (child2 !== null) {\n      var sibling2 = child2.next;\n      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;\n      pause_children(child2, transitions, transparent ? local : false);\n      child2 = sibling2;\n    }\n  }\n  function resume_effect(effect2) {\n    resume_children(effect2, true);\n  }\n  function resume_children(effect2, local) {\n    if ((effect2.f & INERT) === 0) return;\n    effect2.f ^= INERT;\n    if (check_dirtiness(effect2)) {\n      update_effect(effect2);\n    }\n    var child2 = effect2.first;\n    while (child2 !== null) {\n      var sibling2 = child2.next;\n      var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;\n      resume_children(child2, transparent ? local : false);\n      child2 = sibling2;\n    }\n    if (effect2.transitions !== null) {\n      for (const transition2 of effect2.transitions) {\n        if (transition2.is_global || local) {\n          transition2.in();\n        }\n      }\n    }\n  }\n  let is_micro_task_queued$1 = false;\n  let current_queued_micro_tasks = [];\n  function process_micro_tasks() {\n    is_micro_task_queued$1 = false;\n    const tasks = current_queued_micro_tasks.slice();\n    current_queued_micro_tasks = [];\n    run_all(tasks);\n  }\n  function queue_micro_task(fn) {\n    if (!is_micro_task_queued$1) {\n      is_micro_task_queued$1 = true;\n      queueMicrotask(process_micro_tasks);\n    }\n    current_queued_micro_tasks.push(fn);\n  }\n  function flush_tasks() {\n    if (is_micro_task_queued$1) {\n      process_micro_tasks();\n    }\n  }\n  function lifecycle_outside_component(name) {\n    {\n      throw new Error(\"lifecycle_outside_component\");\n    }\n  }\n  const FLUSH_MICROTASK = 0;\n  const FLUSH_SYNC = 1;\n  let scheduler_mode = FLUSH_MICROTASK;\n  let is_micro_task_queued = false;\n  let is_flushing_effect = false;\n  let is_destroying_effect = false;\n  function set_is_flushing_effect(value) {\n    is_flushing_effect = value;\n  }\n  function set_is_destroying_effect(value) {\n    is_destroying_effect = value;\n  }\n  let queued_root_effects = [];\n  let flush_count = 0;\n  let active_reaction = null;\n  function set_active_reaction(reaction) {\n    active_reaction = reaction;\n  }\n  let active_effect = null;\n  function set_active_effect(effect2) {\n    active_effect = effect2;\n  }\n  let derived_sources = null;\n  function set_derived_sources(sources) {\n    derived_sources = sources;\n  }\n  let new_deps = null;\n  let skipped_deps = 0;\n  let untracked_writes = null;\n  function set_untracked_writes(value) {\n    untracked_writes = value;\n  }\n  let current_version = 0;\n  let skip_reaction = false;\n  let component_context = null;\n  function set_component_context(context) {\n    component_context = context;\n  }\n  function increment_version() {\n    return ++current_version;\n  }\n  function is_runes() {\n    return component_context !== null && component_context.l === null;\n  }\n  function check_dirtiness(reaction) {\n    var _a, _b;\n    var flags = reaction.f;\n    if ((flags & DIRTY) !== 0) {\n      return true;\n    }\n    if ((flags & MAYBE_DIRTY) !== 0) {\n      var dependencies = reaction.deps;\n      var is_unowned = (flags & UNOWNED) !== 0;\n      if (dependencies !== null) {\n        var i;\n        if ((flags & DISCONNECTED) !== 0) {\n          for (i = 0; i < dependencies.length; i++) {\n            ((_a = dependencies[i]).reactions ?? (_a.reactions = [])).push(reaction);\n          }\n          reaction.f ^= DISCONNECTED;\n        }\n        for (i = 0; i < dependencies.length; i++) {\n          var dependency = dependencies[i];\n          if (check_dirtiness(\n            /** @type {Derived} */\n            dependency\n          )) {\n            update_derived(\n              /** @type {Derived} */\n              dependency\n            );\n          }\n          if (is_unowned && active_effect !== null && !skip_reaction && !((_b = dependency == null ? void 0 : dependency.reactions) == null ? void 0 : _b.includes(reaction))) {\n            (dependency.reactions ?? (dependency.reactions = [])).push(reaction);\n          }\n          if (dependency.version > reaction.version) {\n            return true;\n          }\n        }\n      }\n      if (!is_unowned) {\n        set_signal_status(reaction, CLEAN);\n      }\n    }\n    return false;\n  }\n  function handle_error(error, effect2, component_context2) {\n    {\n      throw error;\n    }\n  }\n  function update_reaction(reaction) {\n    var _a;\n    var previous_deps = new_deps;\n    var previous_skipped_deps = skipped_deps;\n    var previous_untracked_writes = untracked_writes;\n    var previous_reaction = active_reaction;\n    var previous_skip_reaction = skip_reaction;\n    var prev_derived_sources = derived_sources;\n    var previous_component_context = component_context;\n    var flags = reaction.f;\n    new_deps = /** @type {null | Value[]} */\n    null;\n    skipped_deps = 0;\n    untracked_writes = null;\n    active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n    skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;\n    derived_sources = null;\n    component_context = reaction.ctx;\n    try {\n      var result = (\n        /** @type {Function} */\n        (0, reaction.fn)()\n      );\n      var deps = reaction.deps;\n      if (new_deps !== null) {\n        var i;\n        remove_reactions(reaction, skipped_deps);\n        if (deps !== null && skipped_deps > 0) {\n          deps.length = skipped_deps + new_deps.length;\n          for (i = 0; i < new_deps.length; i++) {\n            deps[skipped_deps + i] = new_deps[i];\n          }\n        } else {\n          reaction.deps = deps = new_deps;\n        }\n        if (!skip_reaction) {\n          for (i = skipped_deps; i < deps.length; i++) {\n            ((_a = deps[i]).reactions ?? (_a.reactions = [])).push(reaction);\n          }\n        }\n      } else if (deps !== null && skipped_deps < deps.length) {\n        remove_reactions(reaction, skipped_deps);\n        deps.length = skipped_deps;\n      }\n      return result;\n    } finally {\n      new_deps = previous_deps;\n      skipped_deps = previous_skipped_deps;\n      untracked_writes = previous_untracked_writes;\n      active_reaction = previous_reaction;\n      skip_reaction = previous_skip_reaction;\n      derived_sources = prev_derived_sources;\n      component_context = previous_component_context;\n    }\n  }\n  function remove_reaction(signal, dependency) {\n    let reactions = dependency.reactions;\n    if (reactions !== null) {\n      var index2 = reactions.indexOf(signal);\n      if (index2 !== -1) {\n        var new_length = reactions.length - 1;\n        if (new_length === 0) {\n          reactions = dependency.reactions = null;\n        } else {\n          reactions[index2] = reactions[new_length];\n          reactions.pop();\n        }\n      }\n    }\n    if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear\n    // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n    // allows us to skip the expensive work of disconnecting and immediately reconnecting it\n    (new_deps === null || !new_deps.includes(dependency))) {\n      set_signal_status(dependency, MAYBE_DIRTY);\n      if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n        dependency.f ^= DISCONNECTED;\n      }\n      remove_reactions(\n        /** @type {Derived} **/\n        dependency,\n        0\n      );\n    }\n  }\n  function remove_reactions(signal, start_index) {\n    var dependencies = signal.deps;\n    if (dependencies === null) return;\n    for (var i = start_index; i < dependencies.length; i++) {\n      remove_reaction(signal, dependencies[i]);\n    }\n  }\n  function update_effect(effect2) {\n    var flags = effect2.f;\n    if ((flags & DESTROYED) !== 0) {\n      return;\n    }\n    set_signal_status(effect2, CLEAN);\n    var previous_effect = active_effect;\n    active_effect = effect2;\n    try {\n      destroy_effect_deriveds(effect2);\n      if ((flags & BLOCK_EFFECT) !== 0) {\n        destroy_block_effect_children(effect2);\n      } else {\n        destroy_effect_children(effect2);\n      }\n      execute_effect_teardown(effect2);\n      var teardown2 = update_reaction(effect2);\n      effect2.teardown = typeof teardown2 === \"function\" ? teardown2 : null;\n      effect2.version = current_version;\n      if (DEV) ;\n    } catch (error) {\n      handle_error(\n        /** @type {Error} */\n        error\n      );\n    } finally {\n      active_effect = previous_effect;\n    }\n  }\n  function infinite_loop_guard() {\n    if (flush_count > 1e3) {\n      flush_count = 0;\n      {\n        effect_update_depth_exceeded();\n      }\n    }\n    flush_count++;\n  }\n  function flush_queued_root_effects(root_effects) {\n    var length = root_effects.length;\n    if (length === 0) {\n      return;\n    }\n    infinite_loop_guard();\n    var previously_flushing_effect = is_flushing_effect;\n    is_flushing_effect = true;\n    try {\n      for (var i = 0; i < length; i++) {\n        var effect2 = root_effects[i];\n        if ((effect2.f & CLEAN) === 0) {\n          effect2.f ^= CLEAN;\n        }\n        var collected_effects = [];\n        process_effects(effect2, collected_effects);\n        flush_queued_effects(collected_effects);\n      }\n    } finally {\n      is_flushing_effect = previously_flushing_effect;\n    }\n  }\n  function flush_queued_effects(effects) {\n    var length = effects.length;\n    if (length === 0) return;\n    for (var i = 0; i < length; i++) {\n      var effect2 = effects[i];\n      if ((effect2.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect2)) {\n        update_effect(effect2);\n        if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {\n          if (effect2.teardown === null) {\n            unlink_effect(effect2);\n          } else {\n            effect2.fn = null;\n          }\n        }\n      }\n    }\n  }\n  function process_deferred() {\n    is_micro_task_queued = false;\n    if (flush_count > 1001) {\n      return;\n    }\n    const previous_queued_root_effects = queued_root_effects;\n    queued_root_effects = [];\n    flush_queued_root_effects(previous_queued_root_effects);\n    if (!is_micro_task_queued) {\n      flush_count = 0;\n    }\n  }\n  function schedule_effect(signal) {\n    if (scheduler_mode === FLUSH_MICROTASK) {\n      if (!is_micro_task_queued) {\n        is_micro_task_queued = true;\n        queueMicrotask(process_deferred);\n      }\n    }\n    var effect2 = signal;\n    while (effect2.parent !== null) {\n      effect2 = effect2.parent;\n      var flags = effect2.f;\n      if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n        if ((flags & CLEAN) === 0) return;\n        effect2.f ^= CLEAN;\n      }\n    }\n    queued_root_effects.push(effect2);\n  }\n  function process_effects(effect2, collected_effects) {\n    var current_effect = effect2.first;\n    var effects = [];\n    main_loop: while (current_effect !== null) {\n      var flags = current_effect.f;\n      var is_branch = (flags & BRANCH_EFFECT) !== 0;\n      var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n      if (!is_skippable_branch && (flags & INERT) === 0) {\n        if ((flags & RENDER_EFFECT) !== 0) {\n          if (is_branch) {\n            current_effect.f ^= CLEAN;\n          } else if (check_dirtiness(current_effect)) {\n            update_effect(current_effect);\n          }\n          var child2 = current_effect.first;\n          if (child2 !== null) {\n            current_effect = child2;\n            continue;\n          }\n        } else if ((flags & EFFECT) !== 0) {\n          effects.push(current_effect);\n        }\n      }\n      var sibling2 = current_effect.next;\n      if (sibling2 === null) {\n        let parent = current_effect.parent;\n        while (parent !== null) {\n          if (effect2 === parent) {\n            break main_loop;\n          }\n          var parent_sibling = parent.next;\n          if (parent_sibling !== null) {\n            current_effect = parent_sibling;\n            continue main_loop;\n          }\n          parent = parent.parent;\n        }\n      }\n      current_effect = sibling2;\n    }\n    for (var i = 0; i < effects.length; i++) {\n      child2 = effects[i];\n      collected_effects.push(child2);\n      process_effects(child2, collected_effects);\n    }\n  }\n  function flush_sync(fn) {\n    var previous_scheduler_mode = scheduler_mode;\n    var previous_queued_root_effects = queued_root_effects;\n    try {\n      infinite_loop_guard();\n      const root_effects = [];\n      scheduler_mode = FLUSH_SYNC;\n      queued_root_effects = root_effects;\n      is_micro_task_queued = false;\n      flush_queued_root_effects(previous_queued_root_effects);\n      var result = fn == null ? void 0 : fn();\n      flush_tasks();\n      if (queued_root_effects.length > 0 || root_effects.length > 0) {\n        flush_sync();\n      }\n      flush_count = 0;\n      if (DEV) ;\n      return result;\n    } finally {\n      scheduler_mode = previous_scheduler_mode;\n      queued_root_effects = previous_queued_root_effects;\n    }\n  }\n  function get(signal) {\n    var _a;\n    var flags = signal.f;\n    var is_derived = (flags & DERIVED) !== 0;\n    if (is_derived && (flags & DESTROYED) !== 0) {\n      var value = execute_derived(\n        /** @type {Derived} */\n        signal\n      );\n      destroy_derived(\n        /** @type {Derived} */\n        signal\n      );\n      return value;\n    }\n    if (active_reaction !== null) {\n      if (derived_sources !== null && derived_sources.includes(signal)) {\n        state_unsafe_local_read();\n      }\n      var deps = active_reaction.deps;\n      if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n        skipped_deps++;\n      } else if (new_deps === null) {\n        new_deps = [signal];\n      } else {\n        new_deps.push(signal);\n      }\n      if (untracked_writes !== null && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0 && untracked_writes.includes(signal)) {\n        set_signal_status(active_effect, DIRTY);\n        schedule_effect(active_effect);\n      }\n    } else if (is_derived && /** @type {Derived} */\n    signal.deps === null) {\n      var derived2 = (\n        /** @type {Derived} */\n        signal\n      );\n      var parent = derived2.parent;\n      if (parent !== null && !((_a = parent.deriveds) == null ? void 0 : _a.includes(derived2))) {\n        (parent.deriveds ?? (parent.deriveds = [])).push(derived2);\n      }\n    }\n    if (is_derived) {\n      derived2 = /** @type {Derived} */\n      signal;\n      if (check_dirtiness(derived2)) {\n        update_derived(derived2);\n      }\n    }\n    return signal.v;\n  }\n  function untrack(fn) {\n    const previous_reaction = active_reaction;\n    try {\n      active_reaction = null;\n      return fn();\n    } finally {\n      active_reaction = previous_reaction;\n    }\n  }\n  const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n  function set_signal_status(signal, status) {\n    signal.f = signal.f & STATUS_MASK | status;\n  }\n  function push(props, runes = false, fn) {\n    component_context = {\n      p: component_context,\n      c: null,\n      e: null,\n      m: false,\n      s: props,\n      x: null,\n      l: null\n    };\n    if (!runes) {\n      component_context.l = {\n        s: null,\n        u: null,\n        r1: [],\n        r2: source(false)\n      };\n    }\n  }\n  function pop(component) {\n    const context_stack_item = component_context;\n    if (context_stack_item !== null) {\n      const component_effects = context_stack_item.e;\n      if (component_effects !== null) {\n        var previous_effect = active_effect;\n        var previous_reaction = active_reaction;\n        context_stack_item.e = null;\n        try {\n          for (var i = 0; i < component_effects.length; i++) {\n            var component_effect = component_effects[i];\n            set_active_effect(component_effect.effect);\n            set_active_reaction(component_effect.reaction);\n            effect(component_effect.fn);\n          }\n        } finally {\n          set_active_effect(previous_effect);\n          set_active_reaction(previous_reaction);\n        }\n      }\n      component_context = context_stack_item.p;\n      context_stack_item.m = true;\n    }\n    return (\n      /** @type {T} */\n      {}\n    );\n  }\n  function deep_read_state(value) {\n    if (typeof value !== \"object\" || !value || value instanceof EventTarget) {\n      return;\n    }\n    if (STATE_SYMBOL in value) {\n      deep_read(value);\n    } else if (!Array.isArray(value)) {\n      for (let key in value) {\n        const prop2 = value[key];\n        if (typeof prop2 === \"object\" && prop2 && STATE_SYMBOL in prop2) {\n          deep_read(prop2);\n        }\n      }\n    }\n  }\n  function deep_read(value, visited = /* @__PURE__ */ new Set()) {\n    if (typeof value === \"object\" && value !== null && // We don't want to traverse DOM elements\n    !(value instanceof EventTarget) && !visited.has(value)) {\n      visited.add(value);\n      if (value instanceof Date) {\n        value.getTime();\n      }\n      for (let key in value) {\n        try {\n          deep_read(value[key], visited);\n        } catch (e) {\n        }\n      }\n      const proto = get_prototype_of(value);\n      if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {\n        const descriptors = get_descriptors(proto);\n        for (let key in descriptors) {\n          const get2 = descriptors[key].get;\n          if (get2) {\n            try {\n              get2.call(value);\n            } catch (e) {\n            }\n          }\n        }\n      }\n    }\n  }\n  const all_registered_events = /* @__PURE__ */ new Set();\n  const root_event_handles = /* @__PURE__ */ new Set();\n  function create_event(event_name, dom, handler, options) {\n    function target_handler(event2) {\n      if (!options.capture) {\n        handle_event_propagation.call(dom, event2);\n      }\n      if (!event2.cancelBubble) {\n        var previous_reaction = active_reaction;\n        var previous_effect = active_effect;\n        set_active_reaction(null);\n        set_active_effect(null);\n        try {\n          return handler.call(this, event2);\n        } finally {\n          set_active_reaction(previous_reaction);\n          set_active_effect(previous_effect);\n        }\n      }\n    }\n    if (event_name.startsWith(\"pointer\") || event_name.startsWith(\"touch\") || event_name === \"wheel\") {\n      queue_micro_task(() => {\n        dom.addEventListener(event_name, target_handler, options);\n      });\n    } else {\n      dom.addEventListener(event_name, target_handler, options);\n    }\n    return target_handler;\n  }\n  function event(event_name, dom, handler, capture, passive) {\n    var options = { capture, passive };\n    var target_handler = create_event(event_name, dom, handler, options);\n    if (dom === document.body || dom === window || dom === document) {\n      teardown(() => {\n        dom.removeEventListener(event_name, target_handler, options);\n      });\n    }\n  }\n  function delegate(events) {\n    for (var i = 0; i < events.length; i++) {\n      all_registered_events.add(events[i]);\n    }\n    for (var fn of root_event_handles) {\n      fn(events);\n    }\n  }\n  function handle_event_propagation(event2) {\n    var _a;\n    var handler_element = this;\n    var owner_document = (\n      /** @type {Node} */\n      handler_element.ownerDocument\n    );\n    var event_name = event2.type;\n    var path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];\n    var current_target = (\n      /** @type {null | Element} */\n      path[0] || event2.target\n    );\n    var path_idx = 0;\n    var handled_at = event2.__root;\n    if (handled_at) {\n      var at_idx = path.indexOf(handled_at);\n      if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */\n      window)) {\n        event2.__root = handler_element;\n        return;\n      }\n      var handler_idx = path.indexOf(handler_element);\n      if (handler_idx === -1) {\n        return;\n      }\n      if (at_idx <= handler_idx) {\n        path_idx = at_idx;\n      }\n    }\n    current_target = /** @type {Element} */\n    path[path_idx] || event2.target;\n    if (current_target === handler_element) return;\n    define_property(event2, \"currentTarget\", {\n      configurable: true,\n      get() {\n        return current_target || owner_document;\n      }\n    });\n    var previous_reaction = active_reaction;\n    var previous_effect = active_effect;\n    set_active_reaction(null);\n    set_active_effect(null);\n    try {\n      var throw_error;\n      var other_errors = [];\n      while (current_target !== null) {\n        var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */\n        current_target.host || null;\n        try {\n          var delegated = current_target[\"__\" + event_name];\n          if (delegated !== void 0 && !/** @type {any} */\n          current_target.disabled) {\n            if (is_array(delegated)) {\n              var [fn, ...data] = delegated;\n              fn.apply(current_target, [event2, ...data]);\n            } else {\n              delegated.call(current_target, event2);\n            }\n          }\n        } catch (error) {\n          if (throw_error) {\n            other_errors.push(error);\n          } else {\n            throw_error = error;\n          }\n        }\n        if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {\n          break;\n        }\n        current_target = parent_element;\n      }\n      if (throw_error) {\n        for (let error of other_errors) {\n          queueMicrotask(() => {\n            throw error;\n          });\n        }\n        throw throw_error;\n      }\n    } finally {\n      event2.__root = handler_element;\n      delete event2.currentTarget;\n      set_active_reaction(previous_reaction);\n      set_active_effect(previous_effect);\n    }\n  }\n  function create_fragment_from_html(html2) {\n    var elem = document.createElement(\"template\");\n    elem.innerHTML = html2;\n    return elem.content;\n  }\n  function assign_nodes(start, end) {\n    var effect2 = (\n      /** @type {Effect} */\n      active_effect\n    );\n    if (effect2.nodes_start === null) {\n      effect2.nodes_start = start;\n      effect2.nodes_end = end;\n    }\n  }\n  // @__NO_SIDE_EFFECTS__\n  function template(content, flags) {\n    var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n    var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n    var node;\n    var has_start = !content.startsWith(\"<!>\");\n    return () => {\n      if (node === void 0) {\n        node = create_fragment_from_html(has_start ? content : \"<!>\" + content);\n        if (!is_fragment) node = /** @type {Node} */\n        /* @__PURE__ */ get_first_child(node);\n      }\n      var clone = (\n        /** @type {TemplateNode} */\n        use_import_node ? document.importNode(node, true) : node.cloneNode(true)\n      );\n      if (is_fragment) {\n        var start = (\n          /** @type {TemplateNode} */\n          /* @__PURE__ */ get_first_child(clone)\n        );\n        var end = (\n          /** @type {TemplateNode} */\n          clone.lastChild\n        );\n        assign_nodes(start, end);\n      } else {\n        assign_nodes(clone, clone);\n      }\n      return clone;\n    };\n  }\n  function comment() {\n    var frag = document.createDocumentFragment();\n    var start = document.createComment(\"\");\n    var anchor = create_text();\n    frag.append(start, anchor);\n    assign_nodes(start, anchor);\n    return frag;\n  }\n  function append(anchor, dom) {\n    if (anchor === null) {\n      return;\n    }\n    anchor.before(\n      /** @type {Node} */\n      dom\n    );\n  }\n  const PASSIVE_EVENTS = [\"touchstart\", \"touchmove\"];\n  function is_passive_event(name) {\n    return PASSIVE_EVENTS.includes(name);\n  }\n  let should_intro = true;\n  function set_text(text, value) {\n    var str = value == null ? \"\" : typeof value === \"object\" ? value + \"\" : value;\n    if (str !== (text.__t ?? (text.__t = text.nodeValue))) {\n      text.__t = str;\n      text.nodeValue = str == null ? \"\" : str + \"\";\n    }\n  }\n  function mount(component, options) {\n    return _mount(component, options);\n  }\n  const document_listeners = /* @__PURE__ */ new Map();\n  function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n    init_operations();\n    var registered_events = /* @__PURE__ */ new Set();\n    var event_handle = (events2) => {\n      for (var i = 0; i < events2.length; i++) {\n        var event_name = events2[i];\n        if (registered_events.has(event_name)) continue;\n        registered_events.add(event_name);\n        var passive = is_passive_event(event_name);\n        target.addEventListener(event_name, handle_event_propagation, { passive });\n        var n = document_listeners.get(event_name);\n        if (n === void 0) {\n          document.addEventListener(event_name, handle_event_propagation, { passive });\n          document_listeners.set(event_name, 1);\n        } else {\n          document_listeners.set(event_name, n + 1);\n        }\n      }\n    };\n    event_handle(array_from(all_registered_events));\n    root_event_handles.add(event_handle);\n    var component = void 0;\n    var unmount = effect_root(() => {\n      var anchor_node = anchor ?? target.appendChild(create_text());\n      branch(() => {\n        if (context) {\n          push({});\n          var ctx = (\n            /** @type {ComponentContext} */\n            component_context\n          );\n          ctx.c = context;\n        }\n        if (events) {\n          props.$$events = events;\n        }\n        should_intro = intro;\n        component = Component(anchor_node, props) || {};\n        should_intro = true;\n        if (context) {\n          pop();\n        }\n      });\n      return () => {\n        var _a;\n        for (var event_name of registered_events) {\n          target.removeEventListener(event_name, handle_event_propagation);\n          var n = (\n            /** @type {number} */\n            document_listeners.get(event_name)\n          );\n          if (--n === 0) {\n            document.removeEventListener(event_name, handle_event_propagation);\n            document_listeners.delete(event_name);\n          } else {\n            document_listeners.set(event_name, n);\n          }\n        }\n        root_event_handles.delete(event_handle);\n        mounted_components.delete(component);\n        if (anchor_node !== anchor) {\n          (_a = anchor_node.parentNode) == null ? void 0 : _a.removeChild(anchor_node);\n        }\n      };\n    });\n    mounted_components.set(component, unmount);\n    return component;\n  }\n  let mounted_components = /* @__PURE__ */ new WeakMap();\n  const PENDING = 0;\n  const THEN = 1;\n  const CATCH = 2;\n  function await_block(node, get_input, pending_fn, then_fn, catch_fn) {\n    var anchor = node;\n    var runes = is_runes();\n    var active_component_context = component_context;\n    var input;\n    var pending_effect;\n    var then_effect;\n    var catch_effect;\n    var input_source = (runes ? source : mutable_source)(\n      /** @type {V} */\n      void 0\n    );\n    var error_source = (runes ? source : mutable_source)(void 0);\n    var resolved = false;\n    function update(state2, restore) {\n      resolved = true;\n      if (restore) {\n        set_active_effect(effect2);\n        set_active_reaction(effect2);\n        set_component_context(active_component_context);\n      }\n      if (state2 === PENDING && pending_fn) {\n        if (pending_effect) resume_effect(pending_effect);\n        else pending_effect = branch(() => pending_fn(anchor));\n      }\n      if (state2 === THEN && then_fn) {\n        if (then_effect) resume_effect(then_effect);\n        else then_effect = branch(() => then_fn(anchor, input_source));\n      }\n      if (state2 === CATCH && catch_fn) {\n        if (catch_effect) resume_effect(catch_effect);\n        else catch_effect = branch(() => catch_fn(anchor, error_source));\n      }\n      if (state2 !== PENDING && pending_effect) {\n        pause_effect(pending_effect, () => pending_effect = null);\n      }\n      if (state2 !== THEN && then_effect) {\n        pause_effect(then_effect, () => then_effect = null);\n      }\n      if (state2 !== CATCH && catch_effect) {\n        pause_effect(catch_effect, () => catch_effect = null);\n      }\n      if (restore) {\n        set_component_context(null);\n        set_active_reaction(null);\n        set_active_effect(null);\n        flush_sync();\n      }\n    }\n    var effect2 = block(() => {\n      if (input === (input = get_input())) return;\n      if (is_promise(input)) {\n        var promise = input;\n        resolved = false;\n        promise.then(\n          (value) => {\n            if (promise !== input) return;\n            internal_set(input_source, value);\n            update(THEN, true);\n          },\n          (error) => {\n            if (promise !== input) return;\n            internal_set(error_source, error);\n            update(CATCH, true);\n            {\n              throw error_source.v;\n            }\n          }\n        );\n        {\n          queue_micro_task(() => {\n            if (!resolved) update(PENDING, true);\n          });\n        }\n      } else {\n        internal_set(input_source, input);\n        update(THEN, false);\n      }\n      return () => input = null;\n    });\n  }\n  function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {\n    var anchor = node;\n    var consequent_effect = null;\n    var alternate_effect = null;\n    var condition = null;\n    var flags = elseif ? EFFECT_TRANSPARENT : 0;\n    block(() => {\n      if (condition === (condition = !!get_condition())) return;\n      if (condition) {\n        if (consequent_effect) {\n          resume_effect(consequent_effect);\n        } else {\n          consequent_effect = branch(() => consequent_fn(anchor));\n        }\n        if (alternate_effect) {\n          pause_effect(alternate_effect, () => {\n            alternate_effect = null;\n          });\n        }\n      } else {\n        if (alternate_effect) {\n          resume_effect(alternate_effect);\n        } else if (alternate_fn) {\n          alternate_effect = branch(() => alternate_fn(anchor));\n        }\n        if (consequent_effect) {\n          pause_effect(consequent_effect, () => {\n            consequent_effect = null;\n          });\n        }\n      }\n    }, flags);\n  }\n  let current_each_item = null;\n  function index(_, i) {\n    return i;\n  }\n  function pause_effects(state2, items, controlled_anchor, items_map) {\n    var transitions = [];\n    var length = items.length;\n    for (var i = 0; i < length; i++) {\n      pause_children(items[i].e, transitions, true);\n    }\n    var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n    if (is_controlled) {\n      var parent_node = (\n        /** @type {Element} */\n        /** @type {Element} */\n        controlled_anchor.parentNode\n      );\n      clear_text_content(parent_node);\n      parent_node.append(\n        /** @type {Element} */\n        controlled_anchor\n      );\n      items_map.clear();\n      link(state2, items[0].prev, items[length - 1].next);\n    }\n    run_out_transitions(transitions, () => {\n      for (var i2 = 0; i2 < length; i2++) {\n        var item = items[i2];\n        if (!is_controlled) {\n          items_map.delete(item.k);\n          link(state2, item.prev, item.next);\n        }\n        destroy_effect(item.e, !is_controlled);\n      }\n    });\n  }\n  function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n    var anchor = node;\n    var state2 = { flags, items: /* @__PURE__ */ new Map(), first: null };\n    var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n    if (is_controlled) {\n      var parent_node = (\n        /** @type {Element} */\n        node\n      );\n      anchor = parent_node.appendChild(create_text());\n    }\n    var fallback = null;\n    var was_empty = false;\n    block(() => {\n      var collection = get_collection();\n      var array = is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n      var length = array.length;\n      if (was_empty && length === 0) {\n        return;\n      }\n      was_empty = length === 0;\n      {\n        reconcile(array, state2, anchor, render_fn, flags, get_key);\n      }\n      if (fallback_fn !== null) {\n        if (length === 0) {\n          if (fallback) {\n            resume_effect(fallback);\n          } else {\n            fallback = branch(() => fallback_fn(anchor));\n          }\n        } else if (fallback !== null) {\n          pause_effect(fallback, () => {\n            fallback = null;\n          });\n        }\n      }\n      get_collection();\n    });\n  }\n  function reconcile(array, state2, anchor, render_fn, flags, get_key) {\n    var _a, _b, _c, _d;\n    var is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n    var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n    var length = array.length;\n    var items = state2.items;\n    var first = state2.first;\n    var current = first;\n    var seen;\n    var prev2 = null;\n    var to_animate;\n    var matched = [];\n    var stashed = [];\n    var value;\n    var key;\n    var item;\n    var i;\n    if (is_animated) {\n      for (i = 0; i < length; i += 1) {\n        value = array[i];\n        key = get_key(value, i);\n        item = items.get(key);\n        if (item !== void 0) {\n          (_a = item.a) == null ? void 0 : _a.measure();\n          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(item);\n        }\n      }\n    }\n    for (i = 0; i < length; i += 1) {\n      value = array[i];\n      key = get_key(value, i);\n      item = items.get(key);\n      if (item === void 0) {\n        var child_anchor = current ? (\n          /** @type {TemplateNode} */\n          current.e.nodes_start\n        ) : anchor;\n        prev2 = create_item(\n          child_anchor,\n          state2,\n          prev2,\n          prev2 === null ? state2.first : prev2.next,\n          value,\n          key,\n          i,\n          render_fn,\n          flags\n        );\n        items.set(key, prev2);\n        matched = [];\n        stashed = [];\n        current = prev2.next;\n        continue;\n      }\n      if (should_update) {\n        update_item(item, value, i, flags);\n      }\n      if ((item.e.f & INERT) !== 0) {\n        resume_effect(item.e);\n        if (is_animated) {\n          (_b = item.a) == null ? void 0 : _b.unfix();\n          (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(item);\n        }\n      }\n      if (item !== current) {\n        if (seen !== void 0 && seen.has(item)) {\n          if (matched.length < stashed.length) {\n            var start = stashed[0];\n            var j;\n            prev2 = start.prev;\n            var a = matched[0];\n            var b = matched[matched.length - 1];\n            for (j = 0; j < matched.length; j += 1) {\n              move(matched[j], start, anchor);\n            }\n            for (j = 0; j < stashed.length; j += 1) {\n              seen.delete(stashed[j]);\n            }\n            link(state2, a.prev, b.next);\n            link(state2, prev2, a);\n            link(state2, b, start);\n            current = start;\n            prev2 = b;\n            i -= 1;\n            matched = [];\n            stashed = [];\n          } else {\n            seen.delete(item);\n            move(item, current, anchor);\n            link(state2, item.prev, item.next);\n            link(state2, item, prev2 === null ? state2.first : prev2.next);\n            link(state2, prev2, item);\n            prev2 = item;\n          }\n          continue;\n        }\n        matched = [];\n        stashed = [];\n        while (current !== null && current.k !== key) {\n          if ((current.e.f & INERT) === 0) {\n            (seen ?? (seen = /* @__PURE__ */ new Set())).add(current);\n          }\n          stashed.push(current);\n          current = current.next;\n        }\n        if (current === null) {\n          continue;\n        }\n        item = current;\n      }\n      matched.push(item);\n      prev2 = item;\n      current = item.next;\n    }\n    if (current !== null || seen !== void 0) {\n      var to_destroy = seen === void 0 ? [] : array_from(seen);\n      while (current !== null) {\n        if ((current.e.f & INERT) === 0) {\n          to_destroy.push(current);\n        }\n        current = current.next;\n      }\n      var destroy_length = to_destroy.length;\n      if (destroy_length > 0) {\n        var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n        if (is_animated) {\n          for (i = 0; i < destroy_length; i += 1) {\n            (_c = to_destroy[i].a) == null ? void 0 : _c.measure();\n          }\n          for (i = 0; i < destroy_length; i += 1) {\n            (_d = to_destroy[i].a) == null ? void 0 : _d.fix();\n          }\n        }\n        pause_effects(state2, to_destroy, controlled_anchor, items);\n      }\n    }\n    if (is_animated) {\n      queue_micro_task(() => {\n        var _a2;\n        if (to_animate === void 0) return;\n        for (item of to_animate) {\n          (_a2 = item.a) == null ? void 0 : _a2.apply();\n        }\n      });\n    }\n    active_effect.first = state2.first && state2.first.e;\n    active_effect.last = prev2 && prev2.e;\n  }\n  function update_item(item, value, index2, type) {\n    if ((type & EACH_ITEM_REACTIVE) !== 0) {\n      internal_set(item.v, value);\n    }\n    if ((type & EACH_INDEX_REACTIVE) !== 0) {\n      internal_set(\n        /** @type {Value<number>} */\n        item.i,\n        index2\n      );\n    } else {\n      item.i = index2;\n    }\n  }\n  function create_item(anchor, state2, prev2, next2, value, key, index2, render_fn, flags) {\n    var previous_each_item = current_each_item;\n    try {\n      var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n      var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n      var v = reactive ? mutable ? /* @__PURE__ */ mutable_source(value) : source(value) : value;\n      var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);\n      var item = {\n        i,\n        v,\n        k: key,\n        a: null,\n        // @ts-expect-error\n        e: null,\n        prev: prev2,\n        next: next2\n      };\n      current_each_item = item;\n      item.e = branch(() => render_fn(anchor, v, i), hydrating);\n      item.e.prev = prev2 && prev2.e;\n      item.e.next = next2 && next2.e;\n      if (prev2 === null) {\n        state2.first = item;\n      } else {\n        prev2.next = item;\n        prev2.e.next = item.e;\n      }\n      if (next2 !== null) {\n        next2.prev = item;\n        next2.e.prev = item.e;\n      }\n      return item;\n    } finally {\n      current_each_item = previous_each_item;\n    }\n  }\n  function move(item, next2, anchor) {\n    var end = item.next ? (\n      /** @type {TemplateNode} */\n      item.next.e.nodes_start\n    ) : anchor;\n    var dest = next2 ? (\n      /** @type {TemplateNode} */\n      next2.e.nodes_start\n    ) : anchor;\n    var node = (\n      /** @type {TemplateNode} */\n      item.e.nodes_start\n    );\n    while (node !== end) {\n      var next_node = (\n        /** @type {TemplateNode} */\n        /* @__PURE__ */ get_next_sibling(node)\n      );\n      dest.before(node);\n      node = next_node;\n    }\n  }\n  function link(state2, prev2, next2) {\n    if (prev2 === null) {\n      state2.first = next2;\n    } else {\n      prev2.next = next2;\n      prev2.e.next = next2 && next2.e;\n    }\n    if (next2 !== null) {\n      next2.prev = prev2;\n      next2.e.prev = prev2 && prev2.e;\n    }\n  }\n  function html(node, get_value, svg, mathml, skip_warning) {\n    var anchor = node;\n    var value = \"\";\n    var effect2;\n    block(() => {\n      if (value === (value = get_value() ?? \"\")) {\n        return;\n      }\n      if (effect2 !== void 0) {\n        destroy_effect(effect2);\n        effect2 = void 0;\n      }\n      if (value === \"\") return;\n      effect2 = branch(() => {\n        var html2 = value + \"\";\n        var node2 = create_fragment_from_html(html2);\n        assign_nodes(\n          /** @type {TemplateNode} */\n          /* @__PURE__ */ get_first_child(node2),\n          /** @type {TemplateNode} */\n          node2.lastChild\n        );\n        {\n          anchor.before(node2);\n        }\n      });\n    });\n  }\n  let listening_to_form_reset = false;\n  function add_form_reset_listener() {\n    if (!listening_to_form_reset) {\n      listening_to_form_reset = true;\n      document.addEventListener(\n        \"reset\",\n        (evt) => {\n          Promise.resolve().then(() => {\n            var _a;\n            if (!evt.defaultPrevented) {\n              for (\n                const e of\n                /**@type {HTMLFormElement} */\n                evt.target.elements\n              ) {\n                (_a = e.__on_r) == null ? void 0 : _a.call(e);\n              }\n            }\n          });\n        },\n        // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n        { capture: true }\n      );\n    }\n  }\n  function set_attribute(element, attribute, value, skip_warning) {\n    var attributes = element.__attributes ?? (element.__attributes = {});\n    if (attributes[attribute] === (attributes[attribute] = value)) return;\n    if (attribute === \"style\" && \"__styles\" in element) {\n      element.__styles = {};\n    }\n    if (attribute === \"loading\") {\n      element[LOADING_ATTR_SYMBOL] = value;\n    }\n    if (value == null) {\n      element.removeAttribute(attribute);\n    } else if (typeof value !== \"string\" && get_setters(element).includes(attribute)) {\n      element[attribute] = value;\n    } else {\n      element.setAttribute(attribute, value);\n    }\n  }\n  var setters_cache = /* @__PURE__ */ new Map();\n  function get_setters(element) {\n    var setters = setters_cache.get(element.nodeName);\n    if (setters) return setters;\n    setters_cache.set(element.nodeName, setters = []);\n    var descriptors;\n    var proto = get_prototype_of(element);\n    var element_proto = Element.prototype;\n    while (element_proto !== proto) {\n      descriptors = get_descriptors(proto);\n      for (var key in descriptors) {\n        if (descriptors[key].set) {\n          setters.push(key);\n        }\n      }\n      proto = get_prototype_of(proto);\n    }\n    return setters;\n  }\n  function set_class(dom, value) {\n    var prev_class_name = dom.__className;\n    var next_class_name = to_class(value);\n    if (prev_class_name !== next_class_name || hydrating) {\n      if (value == null) {\n        dom.removeAttribute(\"class\");\n      } else {\n        dom.className = next_class_name;\n      }\n      dom.__className = next_class_name;\n    }\n  }\n  function to_class(value) {\n    return value == null ? \"\" : value;\n  }\n  function set_style(dom, key, value, important) {\n    var styles = dom.__styles ?? (dom.__styles = {});\n    if (styles[key] === value) {\n      return;\n    }\n    styles[key] = value;\n    if (value == null) {\n      dom.style.removeProperty(key);\n    } else {\n      dom.style.setProperty(key, value, \"\");\n    }\n  }\n  const request_animation_frame = requestAnimationFrame;\n  const now = () => performance.now();\n  const raf = {\n    tick: (\n      /** @param {any} _ */\n      (_) => request_animation_frame(_)\n    ),\n    now: () => now(),\n    tasks: /* @__PURE__ */ new Set()\n  };\n  function run_tasks(now2) {\n    raf.tasks.forEach((task) => {\n      if (!task.c(now2)) {\n        raf.tasks.delete(task);\n        task.f();\n      }\n    });\n    if (raf.tasks.size !== 0) {\n      raf.tick(run_tasks);\n    }\n  }\n  function loop(callback) {\n    let task;\n    if (raf.tasks.size === 0) {\n      raf.tick(run_tasks);\n    }\n    return {\n      promise: new Promise((fulfill) => {\n        raf.tasks.add(task = { c: callback, f: fulfill });\n      }),\n      abort() {\n        raf.tasks.delete(task);\n      }\n    };\n  }\n  function dispatch_event(element, type) {\n    element.dispatchEvent(new CustomEvent(type));\n  }\n  function css_property_to_camelcase(style) {\n    if (style === \"float\") return \"cssFloat\";\n    if (style === \"offset\") return \"cssOffset\";\n    if (style.startsWith(\"--\")) return style;\n    const parts = style.split(\"-\");\n    if (parts.length === 1) return parts[0];\n    return parts[0] + parts.slice(1).map(\n      /** @param {any} word */\n      (word) => word[0].toUpperCase() + word.slice(1)\n    ).join(\"\");\n  }\n  function css_to_keyframe(css) {\n    const keyframe = {};\n    const parts = css.split(\";\");\n    for (const part of parts) {\n      const [property, value] = part.split(\":\");\n      if (!property || value === void 0) break;\n      const formatted_property = css_property_to_camelcase(property.trim());\n      keyframe[formatted_property] = value.trim();\n    }\n    return keyframe;\n  }\n  const linear$1 = (t) => t;\n  function transition(flags, element, get_fn, get_params) {\n    var is_intro = (flags & TRANSITION_IN) !== 0;\n    var is_outro = (flags & TRANSITION_OUT) !== 0;\n    var is_both = is_intro && is_outro;\n    var is_global = (flags & TRANSITION_GLOBAL) !== 0;\n    var direction = is_both ? \"both\" : is_intro ? \"in\" : \"out\";\n    var current_options;\n    var inert = element.inert;\n    var intro;\n    var outro;\n    function get_options() {\n      var previous_reaction = active_reaction;\n      var previous_effect = active_effect;\n      set_active_reaction(null);\n      set_active_effect(null);\n      try {\n        return current_options ?? (current_options = get_fn()(element, (get_params == null ? void 0 : get_params()) ?? /** @type {P} */\n        {}, {\n          direction\n        }));\n      } finally {\n        set_active_reaction(previous_reaction);\n        set_active_effect(previous_effect);\n      }\n    }\n    var transition2 = {\n      is_global,\n      in() {\n        var _a;\n        element.inert = inert;\n        if (!is_intro) {\n          outro == null ? void 0 : outro.abort();\n          (_a = outro == null ? void 0 : outro.reset) == null ? void 0 : _a.call(outro);\n          return;\n        }\n        if (!is_outro) {\n          intro == null ? void 0 : intro.abort();\n        }\n        dispatch_event(element, \"introstart\");\n        intro = animate(element, get_options(), outro, 1, () => {\n          dispatch_event(element, \"introend\");\n          intro == null ? void 0 : intro.abort();\n          intro = current_options = void 0;\n        });\n      },\n      out(fn) {\n        if (!is_outro) {\n          fn == null ? void 0 : fn();\n          current_options = void 0;\n          return;\n        }\n        element.inert = true;\n        dispatch_event(element, \"outrostart\");\n        outro = animate(element, get_options(), intro, 0, () => {\n          dispatch_event(element, \"outroend\");\n          fn == null ? void 0 : fn();\n        });\n      },\n      stop: () => {\n        intro == null ? void 0 : intro.abort();\n        outro == null ? void 0 : outro.abort();\n      }\n    };\n    var e = (\n      /** @type {Effect} */\n      active_effect\n    );\n    (e.transitions ?? (e.transitions = [])).push(transition2);\n    if (is_intro && should_intro) {\n      var run2 = is_global;\n      if (!run2) {\n        var block2 = (\n          /** @type {Effect | null} */\n          e.parent\n        );\n        while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {\n          while (block2 = block2.parent) {\n            if ((block2.f & BLOCK_EFFECT) !== 0) break;\n          }\n        }\n        run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;\n      }\n      if (run2) {\n        effect(() => {\n          untrack(() => transition2.in());\n        });\n      }\n    }\n  }\n  function animate(element, options, counterpart, t2, on_finish) {\n    var is_intro = t2 === 1;\n    if (is_function(options)) {\n      var a;\n      var aborted = false;\n      queue_micro_task(() => {\n        if (aborted) return;\n        var o = options({ direction: is_intro ? \"in\" : \"out\" });\n        a = animate(element, o, counterpart, t2, on_finish);\n      });\n      return {\n        abort: () => {\n          aborted = true;\n          a == null ? void 0 : a.abort();\n        },\n        deactivate: () => a.deactivate(),\n        reset: () => a.reset(),\n        t: () => a.t()\n      };\n    }\n    counterpart == null ? void 0 : counterpart.deactivate();\n    if (!(options == null ? void 0 : options.duration)) {\n      on_finish();\n      return {\n        abort: noop,\n        deactivate: noop,\n        reset: noop,\n        t: () => t2\n      };\n    }\n    const { delay = 0, css, tick, easing = linear$1 } = options;\n    var keyframes = [];\n    if (is_intro && counterpart === void 0) {\n      if (tick) {\n        tick(0, 1);\n      }\n      if (css) {\n        var styles = css_to_keyframe(css(0, 1));\n        keyframes.push(styles, styles);\n      }\n    }\n    var get_t = () => 1 - t2;\n    var animation = element.animate(keyframes, { duration: delay });\n    animation.onfinish = () => {\n      var t1 = (counterpart == null ? void 0 : counterpart.t()) ?? 1 - t2;\n      counterpart == null ? void 0 : counterpart.abort();\n      var delta = t2 - t1;\n      var duration = (\n        /** @type {number} */\n        options.duration * Math.abs(delta)\n      );\n      var keyframes2 = [];\n      if (duration > 0) {\n        if (css) {\n          var n = Math.ceil(duration / (1e3 / 60));\n          for (var i = 0; i <= n; i += 1) {\n            var t = t1 + delta * easing(i / n);\n            var styles2 = css(t, 1 - t);\n            keyframes2.push(css_to_keyframe(styles2));\n          }\n        }\n        get_t = () => {\n          var time = (\n            /** @type {number} */\n            /** @type {globalThis.Animation} */\n            animation.currentTime\n          );\n          return t1 + delta * easing(time / duration);\n        };\n        if (tick) {\n          loop(() => {\n            if (animation.playState !== \"running\") return false;\n            var t3 = get_t();\n            tick(t3, 1 - t3);\n            return true;\n          });\n        }\n      }\n      animation = element.animate(keyframes2, { duration, fill: \"forwards\" });\n      animation.onfinish = () => {\n        get_t = () => t2;\n        tick == null ? void 0 : tick(t2, 1 - t2);\n        on_finish();\n      };\n    };\n    return {\n      abort: () => {\n        if (animation) {\n          animation.cancel();\n          animation.effect = null;\n          animation.onfinish = noop;\n        }\n      },\n      deactivate: () => {\n        on_finish = noop;\n      },\n      reset: () => {\n        if (t2 === 0) {\n          tick == null ? void 0 : tick(1, 0);\n        }\n      },\n      t: () => get_t()\n    };\n  }\n  function listen_to_event_and_reset_event(element, event2, handler, on_reset = handler) {\n    element.addEventListener(event2, handler);\n    const prev2 = element.__on_r;\n    if (prev2) {\n      element.__on_r = () => {\n        prev2();\n        on_reset();\n      };\n    } else {\n      element.__on_r = on_reset;\n    }\n    add_form_reset_listener();\n  }\n  function bind_value(input, get2, set2 = get2) {\n    var runes = is_runes();\n    listen_to_event_and_reset_event(input, \"input\", () => {\n      var value = is_numberlike_input(input) ? to_number(input.value) : input.value;\n      set2(value);\n      if (runes && value !== (value = get2())) {\n        input.value = value ?? \"\";\n      }\n    });\n    render_effect(() => {\n      var value = get2();\n      if (is_numberlike_input(input) && value === to_number(input.value)) {\n        return;\n      }\n      if (input.type === \"date\" && !value && !input.value) {\n        return;\n      }\n      if (value !== input.value) {\n        input.value = value ?? \"\";\n      }\n    });\n  }\n  function is_numberlike_input(input) {\n    var type = input.type;\n    return type === \"number\" || type === \"range\";\n  }\n  function to_number(value) {\n    return value === \"\" ? null : +value;\n  }\n  function is_bound_this(bound_value, element_or_component) {\n    return bound_value === element_or_component || (bound_value == null ? void 0 : bound_value[STATE_SYMBOL]) === element_or_component;\n  }\n  function bind_this(element_or_component = {}, update, get_value, get_parts) {\n    effect(() => {\n      var old_parts;\n      var parts;\n      render_effect(() => {\n        old_parts = parts;\n        parts = [];\n        untrack(() => {\n          if (element_or_component !== get_value(...parts)) {\n            update(element_or_component, ...parts);\n            if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n              update(null, ...old_parts);\n            }\n          }\n        });\n      });\n      return () => {\n        queue_micro_task(() => {\n          if (parts && is_bound_this(get_value(...parts), element_or_component)) {\n            update(null, ...parts);\n          }\n        });\n      };\n    });\n    return element_or_component;\n  }\n  function init(immutable = false) {\n    const context = (\n      /** @type {ComponentContextLegacy} */\n      component_context\n    );\n    const callbacks = context.l.u;\n    if (!callbacks) return;\n    let props = () => deep_read_state(context.s);\n    if (immutable) {\n      let version = 0;\n      let prev2 = (\n        /** @type {Record<string, any>} */\n        {}\n      );\n      const d = /* @__PURE__ */ derived(() => {\n        let changed = false;\n        const props2 = context.s;\n        for (const key in props2) {\n          if (props2[key] !== prev2[key]) {\n            prev2[key] = props2[key];\n            changed = true;\n          }\n        }\n        if (changed) version++;\n        return version;\n      });\n      props = () => get(d);\n    }\n    if (callbacks.b.length) {\n      user_pre_effect(() => {\n        observe_all(context, props);\n        run_all(callbacks.b);\n      });\n    }\n    user_effect(() => {\n      const fns = untrack(() => callbacks.m.map(run));\n      return () => {\n        for (const fn of fns) {\n          if (typeof fn === \"function\") {\n            fn();\n          }\n        }\n      };\n    });\n    if (callbacks.a.length) {\n      user_effect(() => {\n        observe_all(context, props);\n        run_all(callbacks.a);\n      });\n    }\n  }\n  function observe_all(context, props) {\n    if (context.l.s) {\n      for (const signal of context.l.s) get(signal);\n    }\n    props();\n  }\n  let is_store_binding = false;\n  function capture_store_binding(fn) {\n    var previous_is_store_binding = is_store_binding;\n    try {\n      is_store_binding = false;\n      return [fn(), is_store_binding];\n    } finally {\n      is_store_binding = previous_is_store_binding;\n    }\n  }\n  function with_parent_branch(fn) {\n    var effect2 = active_effect;\n    var previous_effect = active_effect;\n    while (effect2 !== null && (effect2.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\n      effect2 = effect2.parent;\n    }\n    try {\n      set_active_effect(effect2);\n      return fn();\n    } finally {\n      set_active_effect(previous_effect);\n    }\n  }\n  function prop(props, key, flags, fallback) {\n    var _a;\n    var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n    var runes = (flags & PROPS_IS_RUNES) !== 0;\n    var bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n    var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n    var is_store_sub = false;\n    var prop_value;\n    if (bindable) {\n      [prop_value, is_store_sub] = capture_store_binding(() => (\n        /** @type {V} */\n        props[key]\n      ));\n    } else {\n      prop_value = /** @type {V} */\n      props[key];\n    }\n    var setter = (_a = get_descriptor(props, key)) == null ? void 0 : _a.set;\n    var fallback_value = (\n      /** @type {V} */\n      fallback\n    );\n    var fallback_dirty = true;\n    var fallback_used = false;\n    var get_fallback = () => {\n      fallback_used = true;\n      if (fallback_dirty) {\n        fallback_dirty = false;\n        if (lazy) {\n          fallback_value = untrack(\n            /** @type {() => V} */\n            fallback\n          );\n        } else {\n          fallback_value = /** @type {V} */\n          fallback;\n        }\n      }\n      return fallback_value;\n    };\n    if (prop_value === void 0 && fallback !== void 0) {\n      if (setter && runes) {\n        props_invalid_value();\n      }\n      prop_value = get_fallback();\n      if (setter) setter(prop_value);\n    }\n    var getter;\n    if (runes) {\n      getter = () => {\n        var value = (\n          /** @type {V} */\n          props[key]\n        );\n        if (value === void 0) return get_fallback();\n        fallback_dirty = true;\n        fallback_used = false;\n        return value;\n      };\n    } else {\n      var derived_getter = with_parent_branch(\n        () => (immutable ? derived : derived_safe_equal)(() => (\n          /** @type {V} */\n          props[key]\n        ))\n      );\n      derived_getter.f |= LEGACY_DERIVED_PROP;\n      getter = () => {\n        var value = get(derived_getter);\n        if (value !== void 0) fallback_value = /** @type {V} */\n        void 0;\n        return value === void 0 ? fallback_value : value;\n      };\n    }\n    if ((flags & PROPS_IS_UPDATED) === 0) {\n      return getter;\n    }\n    if (setter) {\n      var legacy_parent = props.$$legacy;\n      return function(value, mutation) {\n        if (arguments.length > 0) {\n          if (!runes || !mutation || legacy_parent || is_store_sub) {\n            setter(mutation ? getter() : value);\n          }\n          return value;\n        } else {\n          return getter();\n        }\n      };\n    }\n    var from_child = false;\n    var was_from_child = false;\n    var inner_current_value = /* @__PURE__ */ mutable_source(prop_value);\n    var current_value = with_parent_branch(\n      () => /* @__PURE__ */ derived(() => {\n        var parent_value = getter();\n        var child_value = get(inner_current_value);\n        var current_derived = (\n          /** @type {Derived} */\n          active_reaction\n        );\n        if (from_child || parent_value === void 0 && (current_derived.f & DESTROYED) !== 0) {\n          from_child = false;\n          was_from_child = true;\n          return child_value;\n        }\n        was_from_child = false;\n        return inner_current_value.v = parent_value;\n      })\n    );\n    if (!immutable) current_value.equals = safe_equals;\n    return function(value, mutation) {\n      if (arguments.length > 0) {\n        const new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n        if (!current_value.equals(new_value)) {\n          from_child = true;\n          set(inner_current_value, new_value);\n          if (fallback_used && fallback_value !== void 0) {\n            fallback_value = new_value;\n          }\n          untrack(() => get(current_value));\n        }\n        return value;\n      }\n      return get(current_value);\n    };\n  }\n  function onMount(fn) {\n    if (component_context === null) {\n      lifecycle_outside_component();\n    }\n    if (component_context.l !== null) {\n      init_update_callbacks(component_context).m.push(fn);\n    } else {\n      user_effect(() => {\n        const cleanup = untrack(fn);\n        if (typeof cleanup === \"function\") return (\n          /** @type {() => void} */\n          cleanup\n        );\n      });\n    }\n  }\n  function init_update_callbacks(context) {\n    var l = (\n      /** @type {ComponentContextLegacy} */\n      context.l\n    );\n    return l.u ?? (l.u = { a: [], b: [], m: [] });\n  }\n  const PUBLIC_VERSION = \"5\";\n  if (typeof window !== \"undefined\")\n    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);\n  var root$5 = /* @__PURE__ */ template(`<div class=\"loadership_ZOJAQ svelte-i1jlc0\"><div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div> <div class=\"svelte-i1jlc0\"></div></div>`);\n  function Spinner($$anchor) {\n    var div = root$5();\n    append($$anchor, div);\n  }\n  var root_1$1 = /* @__PURE__ */ template(`<img class=\"fi svelte-7lhsry\">`);\n  function CountryFlag($$anchor, $$props) {\n    const countryCodes = {\n      Afghanistan: \"af\",\n      Albania: \"al\",\n      Algeria: \"dz\",\n      Andorra: \"ad\",\n      Angola: \"ao\",\n      \"Antigua and Barbuda\": \"ag\",\n      Argentina: \"ar\",\n      Armenia: \"am\",\n      Australia: \"au\",\n      Austria: \"at\",\n      Azerbaijan: \"az\",\n      Bahamas: \"bs\",\n      Bahrain: \"bh\",\n      Bangladesh: \"bd\",\n      Barbados: \"bb\",\n      Belarus: \"by\",\n      Belgium: \"be\",\n      Belize: \"bz\",\n      Benin: \"bj\",\n      Bhutan: \"bt\",\n      Bolivia: \"bo\",\n      \"Bosnia and Herzegovina\": \"ba\",\n      Botswana: \"bw\",\n      Brazil: \"br\",\n      Brunei: \"bn\",\n      Bulgaria: \"bg\",\n      \"Burkina Faso\": \"bf\",\n      Burundi: \"bi\",\n      \"Cabo Verde\": \"cv\",\n      Cambodia: \"kh\",\n      Cameroon: \"cm\",\n      Canada: \"ca\",\n      \"Central African Republic\": \"cf\",\n      Chad: \"td\",\n      Chile: \"cl\",\n      China: \"cn\",\n      Colombia: \"co\",\n      Comoros: \"km\",\n      Congo: \"cg\",\n      \"Costa Rica\": \"cr\",\n      Croatia: \"hr\",\n      Cuba: \"cu\",\n      Curacao: \"cw\",\n      Cyprus: \"cy\",\n      Czechia: \"cz\",\n      \"Christmas Island\": \"cx\",\n      \"Democratic Republic of the Congo\": \"cd\",\n      Denmark: \"dk\",\n      Djibouti: \"dj\",\n      Dominica: \"dm\",\n      \"Dominican Republic\": \"do\",\n      Ecuador: \"ec\",\n      Egypt: \"eg\",\n      \"El Salvador\": \"sv\",\n      \"Equatorial Guinea\": \"gq\",\n      Eritrea: \"er\",\n      Estonia: \"ee\",\n      Eswatini: \"sz\",\n      Ethiopia: \"et\",\n      Fiji: \"fj\",\n      Finland: \"fi\",\n      France: \"fr\",\n      Gabon: \"ga\",\n      Gambia: \"gm\",\n      Georgia: \"ge\",\n      Germany: \"de\",\n      Ghana: \"gh\",\n      Greece: \"gr\",\n      Grenada: \"gd\",\n      Guatemala: \"gt\",\n      Guinea: \"gn\",\n      \"Guinea-Bissau\": \"gw\",\n      Guyana: \"gy\",\n      Haiti: \"ht\",\n      Honduras: \"hn\",\n      Hungary: \"hu\",\n      Iceland: \"is\",\n      India: \"in\",\n      Indonesia: \"id\",\n      Iran: \"ir\",\n      Iraq: \"iq\",\n      Ireland: \"ie\",\n      Israel: \"il\",\n      Italy: \"it\",\n      Jamaica: \"jm\",\n      Japan: \"jp\",\n      Jordan: \"jo\",\n      Kazakhstan: \"kz\",\n      Kenya: \"ke\",\n      Kiribati: \"ki\",\n      Kuwait: \"kw\",\n      Kyrgyzstan: \"kg\",\n      Laos: \"la\",\n      Latvia: \"lv\",\n      Lebanon: \"lb\",\n      Lesotho: \"ls\",\n      Liberia: \"lr\",\n      Libya: \"ly\",\n      Liechtenstein: \"li\",\n      Lithuania: \"lt\",\n      Luxembourg: \"lu\",\n      Madagascar: \"mg\",\n      Malawi: \"mw\",\n      Malaysia: \"my\",\n      Maldives: \"mv\",\n      Mali: \"ml\",\n      Malta: \"mt\",\n      \"Marshall Islands\": \"mh\",\n      Mauritania: \"mr\",\n      Mauritius: \"mu\",\n      Mexico: \"mx\",\n      Micronesia: \"fm\",\n      Moldova: \"md\",\n      Monaco: \"mc\",\n      Mongolia: \"mn\",\n      Montenegro: \"me\",\n      Morocco: \"ma\",\n      Mozambique: \"mz\",\n      Myanmar: \"mm\",\n      Namibia: \"na\",\n      Nauru: \"nr\",\n      Nepal: \"np\",\n      Netherlands: \"nl\",\n      \"New Zealand\": \"nz\",\n      Nicaragua: \"ni\",\n      Niger: \"ne\",\n      Nigeria: \"ng\",\n      \"North Korea\": \"kp\",\n      \"North Macedonia\": \"mk\",\n      Norway: \"no\",\n      Oman: \"om\",\n      Pakistan: \"pk\",\n      Palau: \"pw\",\n      \"Palestine State\": \"ps\",\n      Panama: \"pa\",\n      \"Papua New Guinea\": \"pg\",\n      Paraguay: \"py\",\n      Peru: \"pe\",\n      Philippines: \"ph\",\n      Poland: \"pl\",\n      Portugal: \"pt\",\n      \"Puerto Rico\": \"pr\",\n      Qatar: \"qa\",\n      Romania: \"ro\",\n      Russia: \"ru\",\n      Rwanda: \"rw\",\n      \"Saint Kitts and Nevis\": \"kn\",\n      \"Saint Lucia\": \"lc\",\n      \"Saint Vincent and the Grenadines\": \"vc\",\n      Samoa: \"ws\",\n      \"San Marino\": \"sm\",\n      \"Sao Tome and Principe\": \"st\",\n      \"Saudi Arabia\": \"sa\",\n      Senegal: \"sn\",\n      Serbia: \"rs\",\n      Seychelles: \"sc\",\n      \"Sierra Leone\": \"sl\",\n      Singapore: \"sg\",\n      Slovakia: \"sk\",\n      Slovenia: \"si\",\n      \"Solomon Islands\": \"sb\",\n      Somalia: \"so\",\n      \"South Africa\": \"za\",\n      \"South Korea\": \"kr\",\n      \"South Sudan\": \"ss\",\n      Spain: \"es\",\n      \"Sri Lanka\": \"lk\",\n      Sudan: \"sd\",\n      Suriname: \"sr\",\n      Sweden: \"se\",\n      Switzerland: \"ch\",\n      Syria: \"sy\",\n      Taiwan: \"tw\",\n      Tajikistan: \"tj\",\n      Tanzania: \"tz\",\n      Thailand: \"th\",\n      \"Timor-Leste\": \"tl\",\n      Togo: \"tg\",\n      Tonga: \"to\",\n      \"Trinidad and Tobago\": \"tt\",\n      Tunisia: \"tn\",\n      Turkey: \"tr\",\n      Turkmenistan: \"tm\",\n      Tuvalu: \"tv\",\n      Uganda: \"ug\",\n      Ukraine: \"ua\",\n      \"United Arab Emirates\": \"ae\",\n      \"United Kingdom\": \"gb\",\n      \"United States of America\": \"us\",\n      \"United States\": \"us\",\n      Uruguay: \"uy\",\n      Uzbekistan: \"uz\",\n      Vanuatu: \"vu\",\n      \"Vatican City\": \"va\",\n      Venezuela: \"ve\",\n      Vietnam: \"vn\",\n      Yemen: \"ye\",\n      Zambia: \"zm\",\n      Zimbabwe: \"zw\"\n    };\n    const countryCode = countryCodes[$$props.countryName];\n    var fragment = comment();\n    var node = first_child(fragment);\n    if_block(node, () => countryCode, ($$anchor2) => {\n      var img = root_1$1();\n      template_effect(() => set_attribute(img, \"src\", `https://purecatamphetamine.github.io/country-flag-icons/3x2/${countryCode.toUpperCase() ?? \"\"}.svg`));\n      template_effect(() => set_attribute(img, \"alt\", $$props.countryName));\n      append($$anchor2, img);\n    });\n    append($$anchor, fragment);\n  }\n  const leftKey = \"geometa:containerStyleLeft\";\n  const topKey = \"geometa:containerStyleTop\";\n  let isDragging = false;\n  let dragOffset = { x: 0, y: 0 };\n  function getSavedPosition(key) {\n    const value = localStorage.getItem(key);\n    if (value && value.startsWith(\"-\")) {\n      return null;\n    }\n    return value;\n  }\n  function setContainerPosition(container) {\n    container.style.left = getSavedPosition(leftKey) ?? container.style.left;\n    container.style.top = getSavedPosition(topKey) ?? container.style.top;\n  }\n  const onPointerDown = (event2, container) => {\n    const target = event2.target;\n    if (target.closest(\"a\") || target.closest(\"button\")) {\n      return;\n    }\n    isDragging = true;\n    container.setPointerCapture(event2.pointerId);\n    dragOffset = {\n      x: event2.clientX - container.getBoundingClientRect().left,\n      y: event2.clientY - container.getBoundingClientRect().top\n    };\n    event2.preventDefault();\n  };\n  const onPointerMove = (event2, container) => {\n    if (isDragging) {\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const containerWidth = container.offsetWidth;\n      const containerHeight = container.offsetHeight;\n      let newLeft = event2.clientX - dragOffset.x;\n      let newTop = event2.clientY - dragOffset.y;\n      if (newLeft < 0) newLeft = 0;\n      if (newLeft + containerWidth > windowWidth) {\n        newLeft = windowWidth - containerWidth;\n      }\n      if (newTop < 0) newTop = 0;\n      if (newTop + containerHeight > windowHeight) {\n        newTop = windowHeight - containerHeight;\n      }\n      container.style.left = `${newLeft}px`;\n      container.style.top = `${newTop}px`;\n    }\n  };\n  const onPointerUp = (event2, container) => {\n    isDragging = false;\n    if (container && container.hasPointerCapture(event2.pointerId)) {\n      container.releasePointerCapture(event2.pointerId);\n    }\n    _unsafeWindow.localStorage.setItem(leftKey, container.style.left);\n    _unsafeWindow.localStorage.setItem(topKey, container.style.top);\n  };\n  const widthKey = \"geometa:containerWidth\";\n  const heightKey = \"geometa:containerHeight\";\n  function setContainerDimensions(container) {\n    const containerWidth = localStorageGetInt(widthKey) || 500;\n    const containerHeight = localStorageGetInt(heightKey) || 400;\n    container.style.width = `${containerWidth}px`;\n    container.style.height = `${containerHeight}px`;\n  }\n  function saveContainerDimensions(entry) {\n    const containerWidth = entry.contentRect.width;\n    const containerHeight = entry.contentRect.height;\n    if (containerWidth !== 0 && containerHeight !== 0) {\n      _unsafeWindow.localStorage.setItem(widthKey, Math.floor(containerWidth).toString());\n      _unsafeWindow.localStorage.setItem(heightKey, Math.floor(containerHeight).toString());\n    }\n  }\n  function prev(__1, currentIndex, images) {\n    set(currentIndex, (get(currentIndex) - 1 + images().length) % images().length);\n  }\n  function next(__2, currentIndex, images) {\n    set(currentIndex, (get(currentIndex) + 1) % images().length);\n  }\n  function handleMouseMove(event2, containerRef, lensX, lensY) {\n    if (!get(containerRef)) return;\n    const rect = get(containerRef).getBoundingClientRect();\n    set(lensX, event2.clientX - rect.left);\n    set(lensY, event2.clientY - rect.top);\n  }\n  var root_4 = /* @__PURE__ */ template(`<div class=\"lens svelte-fofh7f\"></div>`);\n  var root_3$1 = /* @__PURE__ */ template(`<div class=\"image-wrapper svelte-fofh7f\" role=\"img\" aria-label=\"Zoomable image\"><img class=\"responsive-image svelte-fofh7f\"> <!></div>`);\n  var root_6$1 = /* @__PURE__ */ template(`<button></button>`);\n  var root_5$1 = /* @__PURE__ */ template(`<div class=\"controls\"><button class=\"click-area prev-area svelte-fofh7f\" type=\"button\" aria-label=\"Previous image\"><span class=\"prev svelte-fofh7f\">&#10094;</span></button> <button class=\"click-area next-area svelte-fofh7f\" type=\"button\" aria-label=\"Next image\"><span class=\"next svelte-fofh7f\">&#10095;</span></button></div> <div class=\"indicators svelte-fofh7f\"></div>`, 1);\n  var root$4 = /* @__PURE__ */ template(`<div class=\"carousel svelte-fofh7f\"><!> <!></div>`);\n  function Carousel($$anchor, $$props) {\n    push($$props, false);\n    let images = prop($$props, \"images\", 24, () => []);\n    let currentIndex = mutable_state(0);\n    let containerRef = mutable_state(null);\n    let imageRef = mutable_state(null);\n    let isZoomed = mutable_state(false);\n    let lensX = mutable_state(0);\n    let lensY = mutable_state(0);\n    let lensSize = 150;\n    let scale = 2;\n    function handleMouseEnter() {\n      set(isZoomed, true);\n    }\n    function handleMouseLeave() {\n      set(isZoomed, false);\n    }\n    init();\n    var div = root$4();\n    var node = child(div);\n    if_block(node, () => images().length, ($$anchor2) => {\n      var fragment = comment();\n      var node_1 = first_child(fragment);\n      each(node_1, 1, images, index, ($$anchor3, image, index2) => {\n        var fragment_1 = comment();\n        var node_2 = first_child(fragment_1);\n        if_block(node_2, () => index2 === get(currentIndex), ($$anchor4) => {\n          var div_1 = root_3$1();\n          bind_this(div_1, ($$value) => set(containerRef, $$value), () => get(containerRef));\n          div_1.__mousemove = [handleMouseMove, containerRef, lensX, lensY];\n          var img = child(div_1);\n          bind_this(img, ($$value) => set(imageRef, $$value), () => get(imageRef));\n          set_attribute(img, \"alt\", `Image ${index2 + 1}`);\n          var node_3 = sibling(img, 2);\n          if_block(node_3, () => get(isZoomed) && get(imageRef), ($$anchor5) => {\n            var div_2 = root_4();\n            template_effect(() => set_attribute(div_2, \"style\", `\n                /* Position the lens so the mouse is in its center */\n                top: ${get(lensY) - lensSize / 2}px;\n                left: ${get(lensX) - lensSize / 2}px;\n                width: ${lensSize}px;\n                height: ${lensSize}px;\n                background-image: url(${get(image) ?? \"\"});\n                background-repeat: no-repeat;\n                background-size: ${get(imageRef).width * scale}px ${get(imageRef).height * scale}px;\n                background-position: ${-(get(lensX) * scale - lensSize / 2)}px ${-(get(lensY) * scale - lensSize / 2)}px;\n              `));\n            append($$anchor5, div_2);\n          });\n          template_effect(() => set_attribute(img, \"src\", get(image)));\n          event(\"mouseenter\", div_1, handleMouseEnter);\n          event(\"mouseleave\", div_1, handleMouseLeave);\n          append($$anchor4, div_1);\n        });\n        append($$anchor3, fragment_1);\n      });\n      append($$anchor2, fragment);\n    });\n    var node_4 = sibling(node, 2);\n    if_block(node_4, () => images().length > 1, ($$anchor2) => {\n      var fragment_2 = root_5$1();\n      var div_3 = first_child(fragment_2);\n      var button = child(div_3);\n      button.__click = [prev, currentIndex, images];\n      var button_1 = sibling(button, 2);\n      button_1.__click = [next, currentIndex, images];\n      var div_4 = sibling(div_3, 2);\n      each(div_4, 5, images, index, ($$anchor3, _, index2) => {\n        var button_2 = root_6$1();\n        set_attribute(button_2, \"aria-label\", `Switch to image ${index2 + 1}`);\n        button_2.__click = () => set(currentIndex, index2);\n        template_effect(() => set_class(button_2, `indicator ${(index2 === get(currentIndex) ? \"active\" : \"\") ?? \"\"} svelte-fofh7f`));\n        append($$anchor3, button_2);\n      });\n      append($$anchor2, fragment_2);\n    });\n    append($$anchor, div);\n    pop();\n  }\n  delegate([\"mousemove\", \"click\"]);\n  const ANNOUNCEMENT_CACHE_KEY = \"geometa:cached-announcement\";\n  const ANNOUNCEMENT_CACHE_DURATION_MS = 60 * 60 * 1e3;\n  const ANNOUNCEMENT_API_URL = \"https://learnablemeta.com/api/userscript/announcement/\";\n  async function getAnnouncement() {\n    try {\n      const cachedItemString = localStorage.getItem(ANNOUNCEMENT_CACHE_KEY);\n      if (cachedItemString) {\n        const cachedEntry = JSON.parse(cachedItemString);\n        const now2 = Date.now();\n        if (now2 - cachedEntry.fetchedAt < ANNOUNCEMENT_CACHE_DURATION_MS) {\n          return cachedEntry.data;\n        } else {\n          localStorage.removeItem(ANNOUNCEMENT_CACHE_KEY);\n        }\n      }\n    } catch (e) {\n      localStorage.removeItem(ANNOUNCEMENT_CACHE_KEY);\n    }\n    return new Promise((resolve) => {\n      _GM_xmlhttpRequest({\n        method: \"GET\",\n        url: ANNOUNCEMENT_API_URL,\n        timeout: 3e3,\n        onload: (response) => {\n          let announcementToCache = null;\n          if (response.status === 200) {\n            try {\n              if (response.responseText && response.responseText.trim().toLowerCase() !== \"null\") {\n                const parsedData = JSON.parse(response.responseText);\n                if (parsedData && typeof parsedData.timestamp === \"number\" && typeof parsedData.htmlMessage === \"string\") {\n                  announcementToCache = parsedData;\n                }\n              }\n            } catch (parseError) {\n              console.error(\"Failed to parse announcement JSON from API:\", parseError, response.responseText);\n            }\n          } else {\n            console.error(`Error fetching announcement from API: ${response.status} ${response.statusText}`);\n          }\n          const itemToCache = {\n            data: announcementToCache,\n            fetchedAt: Date.now()\n          };\n          try {\n            localStorage.setItem(ANNOUNCEMENT_CACHE_KEY, JSON.stringify(itemToCache));\n            console.log(announcementToCache ? \"Fetched announcement cached.\" : \"Fetched 'no announcement' state cached.\");\n          } catch (e) {\n            console.warn(\"Error writing announcement state to localStorage cache:\", e);\n          }\n          resolve(announcementToCache);\n        },\n        onerror: (error) => {\n          console.error(\"Network error fetching announcement from API:\", error);\n          resolve(null);\n        },\n        ontimeout: () => {\n          console.error(\"Timeout fetching announcement from API.\");\n          resolve(null);\n        }\n      });\n    });\n  }\n  const LAST_DISMISSED_ANNOUNCEMENT_TIMESTAMP_KEY = \"geometa:last-dismissed-announcement\";\n  function getLastDismissedAnnouncementTimestamp() {\n    try {\n      const storedValue = localStorage.getItem(LAST_DISMISSED_ANNOUNCEMENT_TIMESTAMP_KEY);\n      if (storedValue) {\n        const timestamp = parseInt(storedValue, 10);\n        return !isNaN(timestamp) ? timestamp : null;\n      }\n      return null;\n    } catch (e) {\n      console.warn(\"LocalStorage Error: Could not retrieve last dismissed announcement timestamp.\", e);\n      return null;\n    }\n  }\n  function markAnnouncementAsDismissed(announcementTimestamp) {\n    if (isNaN(announcementTimestamp)) {\n      console.error(\"Invalid timestamp provided to markAnnouncementAsDismissed. Must be a number.\", announcementTimestamp);\n      return;\n    }\n    try {\n      localStorage.setItem(LAST_DISMISSED_ANNOUNCEMENT_TIMESTAMP_KEY, announcementTimestamp.toString());\n    } catch (e) {\n      console.warn(\"LocalStorage Error: Could not save last dismissed announcement timestamp.\", e);\n    }\n  }\n  function proceed(_, showModal, currentUrl) {\n    set(showModal, false);\n    window.open(get(currentUrl), \"_blank\");\n  }\n  function cancel(__1, showModal) {\n    set(showModal, false);\n  }\n  function togglePopup(__2, showHelpPopup, updateHelpClass) {\n    set(showHelpPopup, !get(showHelpPopup));\n    if (get(showHelpPopup)) {\n      markHelpMessageAsRead();\n      updateHelpClass();\n    }\n  }\n  var on_click = (__3, announcement, lastDismissedTimestamp) => {\n    markAnnouncementAsDismissed(get(announcement).timestamp);\n    set(lastDismissedTimestamp, proxy(get(announcement).timestamp));\n  };\n  var root_2 = /* @__PURE__ */ template(`<div class=\"announcement svelte-a3mhc8\"><div class=\"svelte-a3mhc8\"><!></div> <button class=\"vote-close-btn svelte-a3mhc8\" aria-label=\"Dismiss announcement\">Dismiss</button></div>`);\n  var root_3 = /* @__PURE__ */ template(`<p class=\"svelte-a3mhc8\"> </p>`);\n  var root_6 = /* @__PURE__ */ template(`<p class=\"geometa-footer svelte-a3mhc8\"><!></p>`);\n  var root_7 = /* @__PURE__ */ template(`<hr class=\"svelte-a3mhc8\"> <!>`, 1);\n  var root_5 = /* @__PURE__ */ template(`<p class=\"svelte-a3mhc8\"><!> <strong class=\"svelte-a3mhc8\"> </strong> </p> <div class=\"geometa-note svelte-a3mhc8\"><!></div> <!> <!>`, 1);\n  var root_9 = /* @__PURE__ */ template(`<div class=\"modal-backdrop svelte-a3mhc8\"><div class=\"modal svelte-a3mhc8\"><p class=\"svelte-a3mhc8\">You are about to open this site in a new tab:</p> <p class=\"modal-url svelte-a3mhc8\"> </p> <div class=\"modal-buttons svelte-a3mhc8\"><button class=\"proceed-btn svelte-a3mhc8\">Continue</button> <button class=\"close-btn svelte-a3mhc8\">Cancel</button></div></div></div>`);\n  var root_11 = /* @__PURE__ */ template(`<p class=\"outdated svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\"> </strong></p>`);\n  var root_10 = /* @__PURE__ */ template(`<div class=\"modal-backdrop svelte-a3mhc8\"><div class=\"modal svelte-a3mhc8\"><div class=\"help-message svelte-a3mhc8\"><!> <p class=\"svelte-a3mhc8\">Welcome to LearnableMeta, we hope you are enjoying it, some quick info:</p> <ul class=\"svelte-a3mhc8\"><li class=\"svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\">Drag to Move:</strong> Click and drag the top of the note to reposition it anywhere on your\n              screen.</li> <li class=\"svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\">Resize:</strong> Use the bottom-right corner to resize the note to your liking.</li> <li class=\"svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\">View Map meta list:</strong> Click the list icon to see all the metas included in the map you\n              are currently playing.</li> <li class=\"svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\">Join the Community:</strong> Click the Discord icon to share feedback, suggest improvements, or\n              just say hi!</li> <li class=\"svelte-a3mhc8\"><strong class=\"svelte-a3mhc8\">Outdated Script:</strong> The question mark icon will blink if the script is outdated.</li></ul></div> <button class=\"close-btn svelte-a3mhc8\">Close</button></div></div>`);\n  var root$3 = /* @__PURE__ */ template(`<div class=\"geometa-container svelte-a3mhc8\"><!> <div class=\"flex header svelte-a3mhc8\"><h2 class=\"svelte-a3mhc8\">Learnable Meta</h2> <div class=\"icons svelte-a3mhc8\"><a target=\"_blank\" aria-label=\"List of map metas\" class=\"svelte-a3mhc8\"><span class=\"skill-icons--list svelte-a3mhc8\"></span></a> <a href=\"https://learnablemeta.com/\" target=\"_blank\" aria-label=\"Learnable Meta website\" class=\"svelte-a3mhc8\"><span class=\"flat-color-icons--globe svelte-a3mhc8\"></span></a> <a href=\"https://discord.gg/AcXEWznYZe\" target=\"_blank\" aria-label=\"Learnable Meta discord\" class=\"svelte-a3mhc8\"><span class=\"skill-icons--discord svelte-a3mhc8\"></span></a> <button aria-label=\"More information\" style=\"background: none; border: none; padding: 0;\" class=\"svelte-a3mhc8\"><span></span></button></div></div> <!> <!> <!></div>`);\n  function App($$anchor, $$props) {\n    push($$props, true);\n    let geoInfo = state(null);\n    let error = state(null);\n    let container;\n    let header;\n    onMount(() => {\n      var _a;\n      const cacheKey = `${$$props.mapId}_${$$props.panoId}`;\n      const cachedData = (_a = window.geometaMetaCache) == null ? void 0 : _a.get(cacheKey);\n      if (cachedData) {\n        set(geoInfo, proxy(cachedData));\n      } else {\n        const urlParams = new URLSearchParams({\n          panoId: $$props.panoId,\n          mapId: $$props.mapId,\n          userscriptVersion: $$props.userscriptVersion,\n          source: $$props.source\n        }).toString();\n        const url = `https://learnablemeta.com/api/userscript/location?${urlParams}`;\n        _GM_xmlhttpRequest({\n          method: \"GET\",\n          url,\n          onload: (response) => {\n            if (response.status === 200) {\n              try {\n                const data = JSON.parse(response.responseText);\n                set(geoInfo, proxy(data));\n                if (!window.geometaMetaCache) {\n                  window.geometaMetaCache = /* @__PURE__ */ new Map();\n                }\n                window.geometaMetaCache.set(cacheKey, data);\n              } catch (e) {\n                set(error, \"Failed to parse response\");\n              }\n            } else if (response.status === 404) {\n              set(error, \"Meta for this location not found\");\n            } else {\n              set(error, `HTTP error! status: ${response.status}`);\n            }\n          },\n          onerror: (e) => {\n            set(error, \"An error occurred while fetching data\");\n            console.error(\"Error:\", e);\n          }\n        });\n      }\n      setContainerPosition(container);\n      setContainerDimensions(container);\n      const resizeObserver = new ResizeObserver((entries) => {\n        for (let entry of entries) {\n          saveContainerDimensions(entry);\n        }\n      });\n      resizeObserver.observe(container);\n      header.addEventListener(\"pointerdown\", (event2) => onPointerDown(event2, container));\n      document.addEventListener(\"pointermove\", (event2) => onPointerMove(event2, container));\n      document.addEventListener(\"pointerup\", (event2) => onPointerUp(event2, container));\n      return () => {\n        resizeObserver.disconnect();\n        header.removeEventListener(\"pointerdown\", (event2) => onPointerDown(event2, container));\n        document.removeEventListener(\"pointermove\", (event2) => onPointerMove(event2, container));\n        document.removeEventListener(\"pointerup\", (event2) => onPointerUp(event2, container));\n      };\n    });\n    function confirmNavigation(event2) {\n      event2.preventDefault();\n      set(currentUrl, proxy(event2.currentTarget.href));\n      set(showModal, true);\n    }\n    let showModal = state(false);\n    let currentUrl = state(\"\");\n    let showHelpPopup = state(false);\n    let helpClass = state(\"question-mark-icon\");\n    function shouldBlink() {\n      return !wasHelpMessageRead() || checkIfOutdated();\n    }\n    function updateHelpClass() {\n      set(helpClass, proxy(shouldBlink() ? \"question-mark-icon blink\" : \"question-mark-icon\"));\n    }\n    updateHelpClass();\n    user_effect(() => {\n      if (get(geoInfo)) {\n        const links = document.querySelectorAll(\".geometa-footer a, .geometa-note a\");\n        links.forEach((link2) => {\n          link2.removeEventListener(\"click\", confirmNavigation);\n          link2.addEventListener(\"click\", confirmNavigation);\n        });\n      }\n    });\n    let lastDismissedTimestamp = state(proxy(getLastDismissedAnnouncementTimestamp()));\n    var div = root$3();\n    bind_this(div, ($$value) => container = $$value, () => container);\n    var node = child(div);\n    await_block(node, getAnnouncement, null, ($$anchor2, announcement) => {\n      var fragment = comment();\n      var node_1 = first_child(fragment);\n      if_block(node_1, () => $$props.roundNumber >= 4 && get(announcement) && (!get(lastDismissedTimestamp) || get(announcement).timestamp > get(lastDismissedTimestamp)), ($$anchor3) => {\n        var div_1 = root_2();\n        var div_2 = child(div_1);\n        var node_2 = child(div_2);\n        html(node_2, () => get(announcement).htmlMessage);\n        var button = sibling(div_2, 2);\n        button.__click = [\n          on_click,\n          announcement,\n          lastDismissedTimestamp\n        ];\n        append($$anchor3, div_1);\n      });\n      append($$anchor2, fragment);\n    });\n    var div_3 = sibling(node, 2);\n    bind_this(div_3, ($$value) => header = $$value, () => header);\n    var div_4 = sibling(child(div_3), 2);\n    var a = child(div_4);\n    var button_1 = sibling(a, 6);\n    button_1.__click = [togglePopup, showHelpPopup, updateHelpClass];\n    var span = child(button_1);\n    var node_3 = sibling(div_3, 2);\n    if_block(\n      node_3,\n      () => get(error),\n      ($$anchor2) => {\n        var p = root_3();\n        var text = child(p);\n        template_effect(() => set_text(text, `Error: ${get(error) ?? \"\"}`));\n        append($$anchor2, p);\n      },\n      ($$anchor2) => {\n        var fragment_1 = comment();\n        var node_4 = first_child(fragment_1);\n        if_block(\n          node_4,\n          () => get(geoInfo),\n          ($$anchor3) => {\n            var fragment_2 = root_5();\n            var p_1 = first_child(fragment_2);\n            var node_5 = child(p_1);\n            CountryFlag(node_5, {\n              get countryName() {\n                return get(geoInfo).country;\n              }\n            });\n            var strong = sibling(node_5, 2);\n            var text_1 = child(strong);\n            var text_2 = sibling(strong);\n            var div_5 = sibling(p_1, 2);\n            var node_6 = child(div_5);\n            html(node_6, () => get(geoInfo).note);\n            var node_7 = sibling(div_5, 2);\n            if_block(node_7, () => get(geoInfo).footer, ($$anchor4) => {\n              var p_2 = root_6();\n              var node_8 = child(p_2);\n              html(node_8, () => get(geoInfo).footer);\n              append($$anchor4, p_2);\n            });\n            var node_9 = sibling(node_7, 2);\n            if_block(node_9, () => get(geoInfo).images && get(geoInfo).images.length, ($$anchor4) => {\n              var fragment_3 = root_7();\n              var node_10 = sibling(first_child(fragment_3), 2);\n              Carousel(node_10, {\n                get images() {\n                  return get(geoInfo).images;\n                }\n              });\n              append($$anchor4, fragment_3);\n            });\n            template_effect(() => {\n              set_text(text_1, get(geoInfo).country);\n              set_text(text_2, ` - ${get(geoInfo).metaName ?? \"\"}`);\n            });\n            append($$anchor3, fragment_2);\n          },\n          ($$anchor3) => {\n            Spinner($$anchor3);\n          },\n          true\n        );\n        append($$anchor2, fragment_1);\n      }\n    );\n    var node_11 = sibling(node_3, 2);\n    if_block(node_11, () => get(showModal), ($$anchor2) => {\n      var div_6 = root_9();\n      var div_7 = child(div_6);\n      var p_3 = sibling(child(div_7), 2);\n      var text_3 = child(p_3);\n      var div_8 = sibling(p_3, 2);\n      var button_2 = child(div_8);\n      button_2.__click = [proceed, showModal, currentUrl];\n      var button_3 = sibling(button_2, 2);\n      button_3.__click = [cancel, showModal];\n      template_effect(() => set_text(text_3, get(currentUrl)));\n      append($$anchor2, div_6);\n    });\n    var node_12 = sibling(node_11, 2);\n    if_block(node_12, () => get(showHelpPopup), ($$anchor2) => {\n      var div_9 = root_10();\n      var div_10 = child(div_9);\n      var div_11 = child(div_10);\n      var node_13 = child(div_11);\n      if_block(node_13, checkIfOutdated, ($$anchor3) => {\n        var p_4 = root_11();\n        var strong_1 = child(p_4);\n        var text_4 = child(strong_1);\n        template_effect(() => set_text(text_4, `Your script version is out of date - please install the latest\n              version (${getLatestVersionInfo() ?? \"\"})!`));\n        append($$anchor3, p_4);\n      });\n      var button_4 = sibling(div_11, 2);\n      button_4.__click = [togglePopup, showHelpPopup, updateHelpClass];\n      append($$anchor2, div_9);\n    });\n    template_effect(() => {\n      set_attribute(a, \"href\", \"https://learnablemeta.com/maps/\" + $$props.mapId);\n      set_class(span, `${get(helpClass) ?? \"\"} svelte-a3mhc8`);\n    });\n    append($$anchor, div);\n    pop();\n  }\n  delegate([\"click\"]);\n  const GeoGuessrEventFramework = _unsafeWindow.GeoGuessrEventFramework;\n  let currentObserver = null;\n  let currentPinObserver = null;\n  function clearMetaCache() {\n    if (window.geometaMetaCache) {\n      window.geometaMetaCache.clear();\n    }\n  }\n  function initSinglePlayer() {\n    GeoGuessrEventFramework.init().then(() => {\n      GeoGuessrEventFramework.events.addEventListener(\"game_start\", async (event2) => {\n        clearMetaCache();\n        await getMapInfo(event2.detail.map.id, true);\n      });\n      GeoGuessrEventFramework.events.addEventListener(\"round_end\", async (event2) => {\n        var _a;\n        (_a = document.getElementById(\"geometa-summary\")) == null ? void 0 : _a.remove();\n        const mapInfo = await getMapInfo(event2.detail.map.id, false);\n        if (!mapInfo.mapFound) {\n          logInfo(\"not supported map - skip\");\n          return;\n        }\n        logInfo(\"waiting for the result view to render\");\n        waitForElement('div[data-qa=\"result-view-top\"]').then((container) => {\n          if (!container) {\n            return;\n          }\n          logInfo(\"the result view is rendered\");\n          const element = document.createElement(\"div\");\n          element.id = \"geometa-summary\";\n          container.appendChild(element);\n          const lastRound = event2.detail.rounds[event2.detail.rounds.length - 1];\n          logInfo(\"adding app window\");\n          mount(App, {\n            target: element,\n            props: {\n              roundNumber: event2.detail.rounds.length,\n              panoId: lastRound.location.panoId,\n              mapId: event2.detail.map.id,\n              userscriptVersion: mapInfo.userscriptVersion,\n              source: window.location.href.includes(\"challenge\") ? \"challenge\" : \"map\"\n            }\n          });\n        });\n      });\n      GeoGuessrEventFramework.events.addEventListener(\"game_end\", async (event2) => {\n        console.log(\"game ended\");\n        const panoIds = event2.detail.rounds.map((round) => round.location.panoId);\n        console.log(\"All round pano IDs:\", panoIds);\n        const mapInfo = await getMapInfo(event2.detail.map.id, false);\n        if (!mapInfo.mapFound) {\n          logInfo(\"not supported map for breakdown - skip\");\n          return;\n        }\n        const roundData = { rounds: event2.detail.rounds, mapId: event2.detail.map.id, userscriptVersion: mapInfo.userscriptVersion };\n        waitForElement(\".result-list_listWrapper__7SmiM\").then((listWrapper) => {\n          if (!listWrapper) {\n            return;\n          }\n          addMetaButtonsToRounds(roundData.rounds, roundData.mapId, roundData.userscriptVersion);\n        });\n        if (currentObserver) {\n          currentObserver.disconnect();\n        }\n        currentObserver = new MutationObserver(() => {\n          const listWrapper = document.querySelector(\".result-list_listWrapper__7SmiM\");\n          if (listWrapper && !listWrapper.querySelector(\".geometa-meta-btn\")) {\n            addMetaButtonsToRounds(roundData.rounds, roundData.mapId, roundData.userscriptVersion);\n          }\n        });\n        currentObserver.observe(document.body, {\n          childList: true,\n          subtree: true\n        });\n        addClickableIconsToPins(roundData.rounds, roundData.mapId, roundData.userscriptVersion);\n      });\n      window.addEventListener(\"urlchange\", () => {\n        clearMetaCache();\n        if (currentObserver) {\n          currentObserver.disconnect();\n          currentObserver = null;\n        }\n        if (currentPinObserver) {\n          currentPinObserver.disconnect();\n          currentPinObserver = null;\n        }\n      });\n    });\n  }\n  function addMetaButtonsToRounds(rounds, mapId, userscriptVersion) {\n    const roundItems = document.querySelectorAll(\".result-list_listItemWrapper___XCGn\");\n    rounds.forEach((round, index2) => {\n      var _a;\n      const roundItem = roundItems[index2];\n      if (!roundItem) return;\n      const roundNumber = (_a = roundItem.querySelector(\".result-list_roundNumber__RlIKm\")) == null ? void 0 : _a.textContent;\n      if (roundNumber === \"Total\") return;\n      if (roundItem.querySelector(\".geometa-meta-btn\")) return;\n      const metaButton = document.createElement(\"button\");\n      metaButton.className = \"geometa-meta-btn\";\n      metaButton.textContent = \"Show meta\";\n      metaButton.title = \"View meta for this round\";\n      metaButton.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        showMetaForRound(round.location.panoId, mapId, userscriptVersion, index2 + 1);\n      });\n      roundItem.appendChild(metaButton);\n    });\n  }\n  function showMetaForRound(panoId, mapId, userscriptVersion, roundNumber) {\n    let element = document.getElementById(\"geometa-summary\");\n    if (element) {\n      element.innerHTML = \"\";\n    } else {\n      const container = document.querySelector('div[data-qa=\"result-view-top\"]') || document.body;\n      element = document.createElement(\"div\");\n      element.id = \"geometa-summary\";\n      container.appendChild(element);\n    }\n    mount(App, {\n      target: element,\n      props: {\n        roundNumber,\n        panoId,\n        mapId,\n        userscriptVersion,\n        source: window.location.href.includes(\"challenge\") ? \"challenge\" : \"map\"\n      }\n    });\n  }\n  function addClickableIconsToPins(rounds, mapId, userscriptVersion) {\n    if (currentPinObserver) {\n      currentPinObserver.disconnect();\n    }\n    currentPinObserver = new MutationObserver(() => {\n      const pins = document.querySelectorAll('[class*=\"map-pin_mapPin\"]');\n      pins.forEach((pin) => {\n        var _a;\n        const pinText = (_a = pin.textContent) == null ? void 0 : _a.trim();\n        const roundNumber = parseInt(pinText || \"\");\n        if (roundNumber >= 1 && roundNumber <= 5 && !pin.hasAttribute(\"data-geometa-pin-processed\")) {\n          pin.setAttribute(\"data-geometa-pin-processed\", \"true\");\n          const questionIcon = document.createElement(\"div\");\n          questionIcon.className = \"geometa-pin-question\";\n          questionIcon.innerHTML = \"?\";\n          questionIcon.title = `View meta for round ${roundNumber}`;\n          questionIcon.addEventListener(\"click\", (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const round = rounds[roundNumber - 1];\n            if (round) {\n              showMetaForRound(round.location.panoId, mapId, userscriptVersion, roundNumber);\n            }\n          });\n          const pinElement = pin;\n          if (pinElement.style.position === \"\" || pinElement.style.position === \"static\") {\n            pinElement.style.position = \"relative\";\n          }\n          pinElement.appendChild(questionIcon);\n        }\n      });\n    });\n    currentPinObserver.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n  }\n  function initLiveChallenge() {\n    logInfo(\"live challenge support enabled\");\n    let pinChanged = false;\n    const observer = new MutationObserver(async (mutations) => {\n      if (!document.querySelector(\"[class*=result-map_roundPin]\")) {\n        pinChanged = false;\n        return;\n      }\n      if (pinChanged) {\n        return;\n      }\n      pinChanged = true;\n      const challengeId = getChallengeId();\n      if (challengeId) {\n        const { mapId, panoId } = await getChallengeInfo(challengeId);\n        const mapInfo = await getMapInfo(mapId, false);\n        if (!mapInfo.mapFound) return;\n        waitForElement(\"[class*=game_container]\").then((container) => {\n          if (!container) {\n            return;\n          }\n          const element = document.createElement(\"div\");\n          element.id = \"geometa-summary\";\n          container.appendChild(element);\n          mount(App, {\n            target: element,\n            props: {\n              // this is to display announcements and there is not easy way to calculate which round it is\n              roundNumber: 4,\n              panoId,\n              mapId,\n              userscriptVersion: mapInfo.userscriptVersion,\n              source: \"liveChallenge\"\n            }\n          });\n        });\n      }\n    });\n    if (document.body) {\n      observer.observe(document.body, { subtree: true, childList: true });\n    } else {\n      console.error(\"document.body is not available.\");\n    }\n  }\n  function initURLChangeEvent() {\n    overrideHistoryMethod(\"pushState\");\n    overrideHistoryMethod(\"replaceState\");\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchange\"));\n    });\n  }\n  function overrideHistoryMethod(method) {\n    const original = history[method];\n    history[method] = function(state2, title, url) {\n      const result = original.call(this, state2, title, url);\n      window.dispatchEvent(new Event(\"urlchange\"));\n      return result;\n    };\n  }\n  var root$2 = /* @__PURE__ */ template(`<div class=\"geometa-map-label-container svelte-1mmcvqu\"><p class=\"svelte-1mmcvqu\">LearnableMeta Enabled</p> <a target=\"_blank\"><button class=\"svelte-1mmcvqu\">Meta List</button></a></div>`);\n  function MapLabel($$anchor, $$props) {\n    var div = root$2();\n    var a = sibling(child(div), 2);\n    template_effect(() => set_attribute(a, \"href\", `https://learnablemeta.com/maps/${$$props.mapId}`));\n    append($$anchor, div);\n  }\n  function initMapLabel() {\n    addMapLabel();\n    window.addEventListener(\"urlchange\", () => {\n      addMapLabel();\n    });\n  }\n  async function addMapLabel() {\n    const mapId = extractMapIdFromUrl(window.location.href);\n    if (!mapId) {\n      return;\n    }\n    const mapAvatarContainer = await waitForElement(\"[class*=map-block_mapImageContainer]\");\n    if (!mapAvatarContainer) {\n      return;\n    }\n    const existingLabel = mapAvatarContainer.querySelector(\".map-label\");\n    if (existingLabel) {\n      existingLabel.remove();\n    }\n    const mapInfo = await getMapInfo(mapId, true);\n    if (!(mapInfo == null ? void 0 : mapInfo.mapFound)) {\n      return;\n    }\n    const element = document.createElement(\"div\");\n    element.classList.add(\"map-label\");\n    mapAvatarContainer.appendChild(element);\n    mount(MapLabel, {\n      target: element,\n      props: {\n        mapId\n      }\n    });\n  }\n  async function geoguessrAPIFetch(url, options = {}) {\n    const { method = \"GET\", headers: initialHeaders, body, ...restOptions } = options;\n    const effectiveHeaders = new Headers(initialHeaders);\n    effectiveHeaders.set(\"Content-Type\", \"application/json\");\n    const response = await fetch(url, {\n      method,\n      headers: effectiveHeaders,\n      body,\n      ...restOptions\n    });\n    if (!response.ok) {\n      let errorPayload = null;\n      let errorMessage = `Request to ${url.substring(0, 100)}... failed with status ${response.status}: ${response.statusText}`;\n      try {\n        const contentType = response.headers.get(\"content-type\");\n        if (contentType && contentType.includes(\"application/json\")) {\n          errorPayload = await response.json();\n          if (errorPayload && errorPayload.message) {\n            errorMessage = `API Error (${response.status}): ${errorPayload.message}`;\n          } else if (errorPayload) {\n            errorMessage = `API Error (${response.status}) for ${url.substring(0, 50)}...: ${JSON.stringify(errorPayload).substring(0, 100)}...`;\n          }\n        } else {\n          const errorText = await response.text();\n          errorPayload = errorText;\n          if (errorText) {\n            errorMessage = `API Error (${response.status}) for ${url.substring(0, 50)}...: ${errorText.substring(0, 100)}...`;\n          }\n        }\n      } catch (e) {\n        console.warn(\"Could not parse error response body from Geoguessr API:\", e);\n      }\n      console.error(`geoguessrAPIFetch Error (Status: ${response.status}) for URL ${url}:`, errorMessage, \"Full Payload:\", errorPayload);\n      throw new Error(errorMessage);\n    }\n    return response;\n  }\n  async function uploadLocations(geoguessrId, apiKey) {\n    const geoguessrDraftApiUrl = `https://www.geoguessr.com/api/v4/user-maps/drafts/${geoguessrId}`;\n    let geoguessrMapDetails;\n    try {\n      const response = await geoguessrAPIFetch(geoguessrDraftApiUrl);\n      geoguessrMapDetails = await response.json();\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(\"Failed to fetch Geoguessr map info:\", error);\n      throw new Error(`Geoguessr Error: Could not fetch map details. ${errorMessage}`);\n    }\n    const { avatar, description, highlighted, name, version } = geoguessrMapDetails;\n    let locationsToUpload;\n    try {\n      locationsToUpload = await fetchMapLocationsGM(geoguessrId, apiKey);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(\"Failed to fetch map locations from backend:\", error);\n      throw new Error(`LearnableMeta Error: ${errorMessage}`);\n    }\n    if (!locationsToUpload || locationsToUpload.length === 0) {\n      const errorMessage = \"Cannot publish an empty map. Please add locations via LearnableMeta first.\";\n      console.warn(errorMessage);\n      throw new Error(errorMessage);\n    }\n    const mapDataToUpload = {\n      avatar,\n      description,\n      highlighted,\n      name,\n      customCoordinates: locationsToUpload,\n      version: version + 1\n    };\n    try {\n      await geoguessrAPIFetch(geoguessrDraftApiUrl, {\n        method: \"PUT\",\n        body: JSON.stringify(mapDataToUpload)\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(\"Failed to update Geoguessr map draft:\", error);\n      throw new Error(`Geoguessr Error: Could not update map draft. ${errorMessage}`);\n    }\n    try {\n      console.log(\"Publishing Geoguessr map...\");\n      await geoguessrAPIFetch(`${geoguessrDraftApiUrl}/publish`, {\n        method: \"PUT\",\n        body: JSON.stringify({})\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      console.error(\"Failed to publish Geoguessr map:\", error);\n      throw new Error(`Geoguessr Error: Could not publish map. ${errorMessage}`);\n    }\n  }\n  function fetchMapLocationsGM(geoguessrId, apiToken) {\n    return new Promise((resolve, reject) => {\n      const apiUrl = `https://learnablemeta.com/api/userscript/map/${geoguessrId}/locations`;\n      _GM_xmlhttpRequest({\n        method: \"GET\",\n        url: apiUrl,\n        headers: {\n          \"Authorization\": `Bearer ${apiToken}`,\n          \"Content-Type\": \"application/json\"\n        },\n        timeout: 15e3,\n        // Add a timeout (e.g., 15 seconds)\n        onload: (response) => {\n          if (response.status >= 200 && response.status < 300) {\n            try {\n              const data = JSON.parse(response.responseText);\n              if (data && Array.isArray(data.customCoordinates)) {\n                resolve(data.customCoordinates);\n              } else {\n                console.error(\"Unexpected data structure from backend:\", data);\n                reject(new Error(\"Received invalid location data structure from backend.\"));\n              }\n            } catch (parseError) {\n              console.error(\"Error parsing JSON response from backend:\", parseError, response.responseText);\n              reject(new Error(`Backend Error: Failed to parse location data: ${parseError.message.substring(0, 100)}`));\n            }\n          } else {\n            let errorMessage = `Backend Error (${response.status}): ${response.statusText || \"Failed to fetch locations\"}`;\n            let rawErrorResponse = response.responseText;\n            try {\n              const parsedJsonError = JSON.parse(response.responseText);\n              if (parsedJsonError && parsedJsonError.message) {\n                errorMessage = `Backend Error (${response.status}): ${parsedJsonError.message}`;\n              } else if (parsedJsonError) {\n                errorMessage = `Backend Error (${response.status}): ${JSON.stringify(parsedJsonError).substring(0, 100)}...`;\n              }\n              rawErrorResponse = parsedJsonError;\n            } catch (e) {\n              if (response.responseText) {\n                errorMessage = `Backend Error (${response.status}): ${response.responseText.substring(0, 100)}...`;\n              }\n            }\n            console.error(`Error fetching map locations from backend (Status: ${response.status}):`, rawErrorResponse);\n            reject(new Error(errorMessage));\n          }\n        },\n        onerror: (error) => {\n          console.error(\"Failed to fetch map locations (XHR onerror):\", error);\n          let detail = error.error || error.statusText || \"Network request failed\";\n          reject(new Error(`Network Error: Could not reach backend to fetch locations. ${detail}`));\n        },\n        ontimeout: () => {\n          console.error(\"Failed to fetch map locations: Request timed out\", apiUrl);\n          reject(new Error(\"Backend Timeout: Request to fetch locations timed out.\"));\n        }\n      });\n    });\n  }\n  const linear = (x) => x;\n  function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {\n    const o = +getComputedStyle(node).opacity;\n    return {\n      delay,\n      duration,\n      easing,\n      css: (t) => `opacity: ${t * o}`\n    };\n  }\n  var root$1 = /* @__PURE__ */ template(`<div role=\"alert\"><span class=\"toast-message svelte-1rq8lsd\"> </span> <button class=\"toast-close-button svelte-1rq8lsd\" aria-label=\"Close\"></button></div>`);\n  function ToastNotification($$anchor, $$props) {\n    let type = prop($$props, \"type\", 3, \"info\");\n    var div = root$1();\n    var span = child(div);\n    var text = child(span);\n    var button = sibling(span, 2);\n    button.__click = function(...$$args) {\n      var _a;\n      (_a = $$props.onClose) == null ? void 0 : _a.apply(this, $$args);\n    };\n    template_effect(() => {\n      set_class(div, `toast-notification toast-${type() ?? \"\"} svelte-1rq8lsd`);\n      set_style(div, \"position\", \"absolute\");\n      set_style(div, \"top\", \"100%\");\n      set_style(div, \"transform\", \"translateX(-75%) translateY(-10px)\");\n      set_style(div, \"margin-top\", \"10px\");\n      set_text(text, $$props.message);\n    });\n    transition(1, div, () => fade, () => ({ duration: 200, delay: 50 }));\n    transition(2, div, () => fade, () => ({ duration: 300 }));\n    append($$anchor, div);\n  }\n  delegate([\"click\"]);\n  async function handleUploadClick(_, isLoading, currentApiKey, getApiKeyFromGM, apiKeyInput, showApiKeyModal, performUpload) {\n    if (get(isLoading)) return;\n    set(currentApiKey, proxy(getApiKeyFromGM()));\n    if (!get(currentApiKey) || get(currentApiKey).trim() === \"\") {\n      set(apiKeyInput, \"\");\n      set(showApiKeyModal, true);\n    } else {\n      await performUpload(get(currentApiKey));\n    }\n  }\n  function handleSaveApiKey(__1, apiKeyInput, saveApiKeyToGM, currentApiKey, showApiKeyModal, showCustomToast, performUpload) {\n    const trimmedKey = get(apiKeyInput).trim();\n    if (trimmedKey) {\n      saveApiKeyToGM(trimmedKey);\n      set(currentApiKey, proxy(trimmedKey));\n      set(showApiKeyModal, false);\n      showCustomToast(\"API Key saved!\", \"success\", 2e3);\n      performUpload(trimmedKey);\n    } else {\n      showCustomToast(\"Please enter a valid API key.\", \"error\", 3e3);\n    }\n  }\n  function handleCancelModal(__2, showApiKeyModal, apiKeyInput) {\n    set(showApiKeyModal, false);\n    set(apiKeyInput, \"\");\n  }\n  var root_1 = /* @__PURE__ */ template(`<div class=\"modal-overlay svelte-17or0cf\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"apiKeyModalTitle\"><div class=\"modal-content svelte-17or0cf\"><h2 id=\"apiKeyModalTitle\" class=\"svelte-17or0cf\">Enter LearnableMeta API Key</h2> <p class=\"svelte-17or0cf\">An API key is required to upload locations. Please paste your key below.</p> <p class=\"svelte-17or0cf\">You can generate your API token by visiting <a target=\"_blank\" rel=\"noopener noreferrer\" class=\"svelte-17or0cf\">profile page</a> on LearnableMeta and generating it there.</p> <input type=\"text\" placeholder=\"Paste your API key here\" aria-label=\"API Key Input\" class=\"modal-input svelte-17or0cf\"> <div class=\"modal-actions svelte-17or0cf\"><button class=\"modal-button modal-button-save svelte-17or0cf\">Save & Upload</button> <button class=\"modal-button modal-button-cancel svelte-17or0cf\">Cancel</button></div> <p class=\"modal-note svelte-17or0cf\">Your API key will be stored securely in your browser's userscript storage for future\n        use.</p></div></div>`);\n  var root = /* @__PURE__ */ template(`<div class=\"upload-label-container\"><button class=\"button_button__aR6_e button_sizeSmall__MB_qj custom-yellow-button svelte-17or0cf\"> </button></div> <!> <!>`, 1);\n  function UploadLocations($$anchor, $$props) {\n    push($$props, true);\n    const API_KEY_STORAGE_NAME = \"learnableMeta_apiKey\";\n    const URL_TO_GENERATE_TOKEN = \"https://learnablemeta.com/profile/token\";\n    let showApiKeyModal = state(false);\n    let apiKeyInput = state(\"\");\n    let currentApiKey = state(null);\n    let isLoading = state(false);\n    let toastState = state(null);\n    let toastTimer = state(void 0);\n    function showCustomToast(message, type = \"info\", duration = 3e3) {\n      clearTimeout(get(toastTimer));\n      const displayToast = () => {\n        set(toastState, proxy({ message, type }));\n        if (duration > 0) {\n          set(toastTimer, proxy(setTimeout(\n            () => {\n              hideCustomToast();\n            },\n            duration\n          )));\n        }\n      };\n      if (get(toastState)) {\n        hideCustomToast();\n        setTimeout(displayToast, 350);\n      } else {\n        displayToast();\n      }\n    }\n    function hideCustomToast() {\n      clearTimeout(get(toastTimer));\n      set(toastState, null);\n    }\n    function getApiKeyFromGM() {\n      try {\n        return _GM_getValue(API_KEY_STORAGE_NAME, null);\n      } catch (e) {\n        console.warn(\"GM_getValue is not available. API key functionality might be limited.\", e);\n        showCustomToast(\"Userscript storage (GM_getValue) is not available. Please ensure Tampermonkey/Violentmonkey is correctly configured.\", \"error\", 0);\n        return null;\n      }\n    }\n    function saveApiKeyToGM(key) {\n      try {\n        _GM_setValue(API_KEY_STORAGE_NAME, key);\n      } catch (e) {\n        console.warn(\"GM_setValue is not available. API key functionality might be limited.\", e);\n        showCustomToast(\"Userscript storage (GM_setValue) is not available. Please ensure Tampermonkey/Violentmonkey is correctly configured.\", \"error\", 0);\n      }\n    }\n    onMount(() => {\n      set(currentApiKey, proxy(getApiKeyFromGM()));\n      if (typeof _GM_registerMenuCommand === \"function\") {\n        _GM_registerMenuCommand(\"LearnableMeta - Set/Update API Key\", () => {\n          set(currentApiKey, null);\n          const newKey = prompt(\"Enter your new LearnableMeta API Key:\");\n          if (newKey && newKey.trim() !== \"\") {\n            saveApiKeyToGM(newKey.trim());\n            set(currentApiKey, proxy(newKey.trim()));\n            showCustomToast(\"LearnableMeta API Key updated!\", \"success\");\n          } else if (newKey !== null) {\n            showCustomToast(\"API Key not updated (empty value provided).\", \"info\");\n          }\n        });\n        _GM_registerMenuCommand(\"LearnableMeta - Clear API Key\", () => {\n          if (confirm(\"Are you sure you want to clear your LearnableMeta API Key?\")) {\n            saveApiKeyToGM(\"\");\n            set(currentApiKey, null);\n            showCustomToast(\"LearnableMeta API Key cleared.\", \"success\");\n          }\n        });\n      }\n    });\n    async function performUpload(apiKey) {\n      set(isLoading, true);\n      try {\n        await uploadLocations($$props.mapId, apiKey);\n        showCustomToast(\"Locations uploaded and map published successfully! The page will refresh shortly.\", \"success\", 4500);\n        setTimeout(\n          () => {\n            window.location.reload();\n          },\n          5e3\n        );\n      } catch (error) {\n        console.error(\"Upload process failed:\", error);\n        let toastMessage = \"An unexpected error occurred during upload.\";\n        if (error && error.message) {\n          toastMessage = error.message;\n        }\n        if (toastMessage.includes(\"401\") || toastMessage.includes(\"403\") || toastMessage.toLowerCase().includes(\"unauthorized\") || toastMessage.toLowerCase().includes(\"invalid token\")) {\n          showCustomToast(`Upload failed: ${toastMessage}. Please check your API Key.`, \"error\", 0);\n        } else {\n          showCustomToast(`Upload failed: ${toastMessage}`, \"error\", 0);\n        }\n        set(isLoading, false);\n      }\n    }\n    var fragment = root();\n    var div = first_child(fragment);\n    var button = child(div);\n    button.__click = [\n      handleUploadClick,\n      isLoading,\n      currentApiKey,\n      getApiKeyFromGM,\n      apiKeyInput,\n      showApiKeyModal,\n      performUpload\n    ];\n    var text = child(button);\n    var node = sibling(div, 2);\n    if_block(node, () => get(showApiKeyModal), ($$anchor2) => {\n      var div_1 = root_1();\n      var div_2 = child(div_1);\n      var p = sibling(child(div_2), 4);\n      var a = sibling(child(p));\n      set_attribute(a, \"href\", URL_TO_GENERATE_TOKEN);\n      var input = sibling(p, 2);\n      var div_3 = sibling(input, 2);\n      var button_1 = child(div_3);\n      button_1.__click = [\n        handleSaveApiKey,\n        apiKeyInput,\n        saveApiKeyToGM,\n        currentApiKey,\n        showApiKeyModal,\n        showCustomToast,\n        performUpload\n      ];\n      var button_2 = sibling(button_1, 2);\n      button_2.__click = [\n        handleCancelModal,\n        showApiKeyModal,\n        apiKeyInput\n      ];\n      bind_value(input, () => get(apiKeyInput), ($$value) => set(apiKeyInput, $$value));\n      append($$anchor2, div_1);\n    });\n    var node_1 = sibling(node, 2);\n    if_block(node_1, () => get(toastState), ($$anchor2) => {\n      ToastNotification($$anchor2, {\n        get message() {\n          return get(toastState).message;\n        },\n        get type() {\n          return get(toastState).type;\n        },\n        onClose: hideCustomToast\n      });\n    });\n    template_effect(() => {\n      button.disabled = get(isLoading);\n      set_text(text, get(isLoading) ? \"Uploading...\" : \"LearnableMeta - Upload\");\n    });\n    append($$anchor, fragment);\n    pop();\n  }\n  delegate([\"click\"]);\n  function extractMapIdFromMapMakerUrl(url) {\n    const match = url.match(/\\/map-maker\\/([^\\/]+)/);\n    return match ? match[1] : null;\n  }\n  function initLocationsUpload() {\n    addLocationsUploadButtons();\n    window.addEventListener(\"urlchange\", () => {\n      addLocationsUploadButtons();\n    });\n  }\n  const containerId = \"geometa-locations-upload\";\n  async function addLocationsUploadButtons() {\n    var _a;\n    const mapId = extractMapIdFromMapMakerUrl(window.location.href);\n    if (!mapId) {\n      return;\n    }\n    (_a = document.getElementById(containerId)) == null ? void 0 : _a.remove();\n    const mapInfo = await getMapInfo(mapId, true);\n    if (!(mapInfo == null ? void 0 : mapInfo.mapFound)) {\n      return;\n    }\n    const targetId = \"geometa-locations-upload-container\";\n    const container = document.querySelector(\".top-bar-menu_topBarMenu__kd9zX\");\n    if (container) {\n      const existingElement = container.querySelector(\"#\" + targetId);\n      if (existingElement) {\n        return;\n      }\n      const target = document.createElement(\"div\");\n      target.id = targetId;\n      container.insertBefore(target, container.lastElementChild);\n      mount(UploadLocations, {\n        target,\n        props: {\n          mapId\n        }\n      });\n    }\n  }\n  function changelog() {\n    return [\n      { \"0.88\": \"Updated framework version for bug-fixes\" },\n      { \"0.87\": \"Added ability to view metas on breakdown screen\" },\n      { \"0.86\": \"Changed look of announcement closing button\" },\n      { \"0.85\": \"Another fix for multiple instances of upload button\" },\n      { \"0.84\": \"Fixed multiple instances of upload button, adjusted styles\" },\n      { \"0.83\": \"Added uploading locations and announcements system\" },\n      { \"0.82\": \"Changed position of LearnableMeta map label for new Geoguessr UI\" },\n      { \"0.81\": \"Fixed live challenge support. Added information about userscript version and source of a call (map, challenge, liveChallenge) to location info request to help us with debugging issues.\" },\n      { \"0.80\": \"Adjusted window dragging to work on mobile. Improved selection mechanism of elements with dynamic class names. Removed special handling of challenges.\" },\n      { \"0.79\": \"Fixed ALM meta list panel when switching to non-ALM map\" },\n      { \"0.78\": \"Added info window with version check\" },\n      { \"0.77\": \"Added custom footer to the note and clicking on link warning\" },\n      { \"0.76\": \"Redesign note and added meta list link\" },\n      { \"0.75\": \"Added basic logging to help with debugging issues\" },\n      { \"0.74\": \"Fixed window appearance when for some reason a negative position value is saved\" },\n      { \"0.73\": \"Fixed live challenge support and updated framework to newest version\" },\n      { \"0.72\": \"Adjusted images to fit vertically to the container to avoid scrolling and added magnifying glass effect on mouse hover\" },\n      { \"0.71\": \"Added beta support for live challenges\" },\n      { \"0.70\": \"Fixed carousel controls jumping and colored the note links\" },\n      { \"0.69\": \"Display multiple images with carousel\" },\n      { \"0.68\": \"Use panoId as unique location identifier, allow html in note\" },\n      { \"0.67\": \"Updated to Svelte 5\" },\n      { \"0.66\": \"Made note movable\" },\n      { \"0.65\": \"Check map ids via API\" },\n      { \"0.64\": \"Added more placeholder map ids\" },\n      { \"0.63\": \"Added container resizing.\" },\n      { \"0.62\": \"Added images to metas.\" },\n      { \"0.61\": \"Added new/placehoder map ids.\" },\n      { \"0.6\": \"Bugfixes\" },\n      { \"0.5\": \"New note format and prepared for multiple maps support\" },\n      {\n        \"0.4\": \"Updated GeoGuessr Event Framework version. Fixes the disappearing daily challenge from GeoGuessr home page.\"\n      }\n    ];\n  }\n  if (_unsafeWindow.notAValidVariable) {\n    console.log(changelog());\n  }\n  initURLChangeEvent();\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", setupLearnableMetaFeatures);\n  } else {\n    await( setupLearnableMetaFeatures());\n  }\n  async function setupLearnableMetaFeatures() {\n    initSinglePlayer();\n    initLiveChallenge();\n    initMapLabel();\n    initLocationsUpload();\n  }\n\n})();",
    "enabled": false,
    "order": 1,
    "url": "https://github.com/likeon/geometa/raw/main/dist/geometa.user.js",
    "version": "0.88",
    "description": "UserScript for GeoGuessr Learnable Meta maps",
    "author": "monkey",
    "requires": [
      "https://raw.githubusercontent.com/miraclewhips/geoguessr-event-framework/5e449d6b64c828fce5d2915772d61c7f95263e34/geoguessr-event-framework.js"
    ],
    "last_updated": 1765264453,
    "last_fetch_error": null
  }
]